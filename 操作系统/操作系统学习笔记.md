[牛逼 史上最全操作系统笔记 拿走 不谢 _惜朝歌的博客-CSDN博客](https://blog.csdn.net/weixin_44075132/article/details/116544280)

# 第一章 基本概念及原理

## 1.1 操作系统是什么

是最基本的**系统软件**

用户角度：操作系统是一个控制软件

*   管理应用程序
*   为应用程序提供服务
*   杀死应用程序

程序角度：操作系统是资源管理器

*   管理外设、分配资源
*   抽象
    *   将CPU抽象成进程
    *   将磁盘抽象成文件
    *   将内存抽象成地址空间











# 第二章 操作系统介绍

+ 操作系统四大特征: 并发, 共享, 虚拟, 异步

  

### 并发

+ 并发与并行
  + 并发: 微观上交替发生, 宏观上同时发生
  + 并行: 指两个或多个事件在同一时刻同时发生。



### 共享

两种资源共享方式

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505102550100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

+ 互斥共享: 如摄像头, 同一时间只能分配给其中一个进程
+ 同时共享, qq 和 微信 交替访问硬盘, 每次读取一部分

+ 并发和共享的关系
  + 并发性指计算机系统中同时存在着**多个运行着的程序**。
  + 共享性是指系统中的**资源**可供内存中多个并发执行的进程共同使用。



### 虚拟

虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。

- 空分复用技术: 物理内存只有4GB, 但实际上可用更多
- 时分复用技术: 把大的时间分为小的时间, CPU轮流执行任务
- 没有并发性, 虚拟就没有意义

### 异步

+ 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，**进程的执行不是一贯到底的**，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

+ 由于并发运行的**程序会争抢着使用系统资源**，而**系统中的资源有限**，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。

+ 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。**只有系统拥有并发性，才有可能导致异步性**。



# 第三章 操作系统的发展

## 手工操作阶段

用户独占全机

## 批处理阶段

### 单道批处理阶段

引入脱机输入 / 输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出

### 多道批处理系统

首次引入并发

没有人机交互功能



## 分时操作系统

以时间片为单位, 轮流为各个客户进行服务

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

主要缺点：**不能优先处理一些紧急任务**。操作系统对各个用户 / 作业都是完全公平的，循环地为每个用户 /作业服务一个时间片，不区分任务的紧急性。



## 实时操作系统

主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性

![在这里插入图片描述](../../../../Pictures/PicBed/MDImage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70.png)



# 中断、异常

## 中断

用户态到核心态的唯一途径

核心态 -> 用户态 : 只需要一个特权指令, 把程序状态字(PSW)设置为用户态

## 中断分类

+ 内外中断的区别在于: 信号来源是CPU内部还是外部
  + 内中断: 和当前指令有关
  + 外中断: 和当前指令无关

### 内中断

+ 也称异常/例外/陷入

+ 分为自愿中断(系统调用) / 强迫中断(软件故障(除以0)/硬件故障)

+ 又分为: 

  + 陷入/陷阱(trap)

    有意为之的中断, 如系统调用

  + 故障(fault)

    由错误条件引起的, 可被修复, 如缺页中断

  + 终止(abort)

    不可恢复, 控制权不再交给引发终止的应用, 如除以0



### 外中断

+ 每一条指令执行结束时，CPU都会例行检查是否有外中断信号

+ 流程

  + 执行完每个指令, 都要检查是否有外中断信号
  + 检测到外中断, 需要保护中断进程的环境(psw / 程序计数器pc / 通用寄存器)
  + 根据中断信号, 转入相应的中断处理程序
  + 恢复原环境, 继续执行

  

# 系统调用

+ **操作系统**作为用户和计算机硬件之间的接口，需要**向上(编程语言)提供**一些简单易用的服务。主要包括**命令接口和程序接口**。其中**程序接口由一组系统调用组成**。

+ “系统调用”是**操作系统提供给应用程序（程序员 / 编程人员）使用**的接口，可以理解为一种**可供应用程序调用的特殊函数**，应用程序可以通过系统调用来请求**获得操作系统内核的服务**

+ 系统调用在**核心态**进行

### 陷入指令

+ 传递系统调用参数—>执行陷入指令（用户态）—> 执行相应的内请求核程序处理系统调用（核心态）—>返回
+ 注意：
  1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态
  2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
  3. 陷入指令是**唯一一个**不能在核心态下执行的指令



# --------------------

# 进程

+ 程序:就是一个指令序列。

+ **程序段、数据段、进程控制块PCB**三部分组成了`进程实体`(进程映像)。一般情况下，我们把进程实体就简称为进程,例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。
+ **PCB是进程存在的唯一标志** !

+ 从不同的角度，进程可以有不同的定义，比较传统典型的定义有:

  1. 进程是程序的一次**执行过程**。
  2. 进程是一个程序及其数据在处理机上顺序执行时所**发生的活动**。
  3. 进程是具有独立功能的程序在数据集合上**运行的过程**，它是系统进行资源分配和调度的一个独立单位。

  + 都在强调动态性

+ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

  注:严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。

## PCB进程控制块

进程的管理者(操作系统)所需的数据都在PCB中

程序本身的运行所需的数据存放在程序段和数据段中

![img](https://img-blog.csdnimg.cn/202105052215334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)



## 进程的组织

为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

+ 链接方式: 以链表方式存储PCB地址, 指向链表头

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505221601693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)



+ 索引方式: 以索引方式存储PCB地址, 指向索引地址



## 进程的特征

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050522162225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)

**最基本**: 动态性



## 进程的状态

+ 三种基本状态

  + 运行态Running:  正在运行, **单核**一次只能有**一个进程**在运行

  + 就绪态Ready: 具备运行条件, 等待空闲CPU

    已经拥有所有需要的资源, 一旦获得CPU就能运行

  + 阻塞态Blocked: 等待某一时间发生, 如分配资源, 等待磁盘读写等

    转化为阻塞态是**主动请求的**, 不能直接就绪 -> 阻塞

+ 另外两种状态: 
  + 创建态: 正在给进程分配资源
  + 终止态: 运行结束, 或者bug导致不能继续运行正在回收资源



<img src="https://img-blog.csdnimg.cn/20210506144726154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:150%;" />



# 进程控制

+ 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有: 
  + 创建新进程
  + 撤销已有进程
  + 实现进程状态转换等功能
    简化理解：反正进程控制就是要实现进程状态转换
+ 有如下几种操作
  + 创建
  + 撤销
  + 阻塞 唤醒
  + 切换

## 原语

+ 进程控制通过**原语**实现: 执行期间不允许被中断

+ 原语会执行**"关中断", "开中断"**指令

  在关后, 开前, 外部中断信号会被忽略



# 进程通信

有两种方式: 共享存储区, 管道通信

### 共享存储

两个进程之间不能直接进行通信, 会由系统开辟一片共享空间, 两个进程对共享空间的访问是**互斥**的, 

+ 基于数据结构的共享: 速度慢, 限制多, 低级通信方式
+ 基于存储区的共享: 画出一块共享存储区, 数据形式/存放位置都由进程控制, 而不是操作系统, 高级通信方式

### 管道通信

管道是一种特殊的贡献文件

+ 管道只能采用**半双工通信**
+ 对管道的访问也是**互斥**的
+ 数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。**（缓冲区的特性）**
+ 如果没写满, 不允许读; 如果没有读空, 不允许写
+ 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。



### 消息传递

+ 进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息 / 接收消息”两个`原语`进行数据交换。
+ 直接消息传递：消息直接挂到接收进程的消息缓冲队列上
+ 间接消息传递：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的**电子邮件系统**



# 线程

+ 进程是程序的一次执行。这些功能显然需要用不同的几段程序才能实现，并且这几段程序还要并发运行

+ 线程是程序执行流的最小单位

+ 引入线程后的变化

  + 资源分配/调度

    传统: 进程既是分配的基本单位, 又是调度的基本单位

    引入后: 进程是分配基本单位, 线程是调度基本单位

  + 并发: 

    传统: 只能进程间并发

    引入后: 可以线程间并发

  + 系统开销:

    传统: 进程间并发, 需要切换进程运行环境, 开销大

    引入后: 如果是同一进程内的线程切换, 不需要切换环境, 开销变小

     

## 线程实现方式

### 用户级线程

+ 由应用程序通过线程库实现, 所有线程管理工作都由应用程序负责
+ 用户级线程中, 线程切换可以在用户态下完成, 不需要系统干预


### 内核级线程

又称内核支持的线程

+ 调度/切换工作需要在**核心态**下, 由系统干预完成



# 多线程模型

## 多对一模型

把多个用户级线程映射到一个内核级线程上

+ 优点: 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
+ 缺点: 当一个用户级线程被阻塞后，**整个进程都会被阻塞**，**并发度不高**。多个线程不可在多核处理机上并行运行



## 一对一模型

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。变成了纯粹的内核级线程

+ 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
+ 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统**内核完成**，需要切换到核心态，因此线程管理的**成本高，开销大**。



## 多对多模型

n 用户及线程映射到m 个内核级线程（n >= m）。每个用户进程对应 m 个内核级线程。

+ 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。



# 调度

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来**决定处理这些任务的顺序**，这就是“调度”研究的问题。



## 高级调度(作业调度)

高级调度是**辅存（外存）与内存之间的调度**。每个作业只调入一次，调出一次。作业**调入时会建立相应的PCB**，作业**调出时才撤销PCB**。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。



## 中级调度(内存调度)

暂时调到外存等待的进程状态为**挂起状态**。值得注意的是，**PCB并不会一起调到外存**，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。

中级调度（内存调度），就是要**决定将哪个处于挂起状态的进程重新调入内存。**

一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



### 低级调度(进程调度)

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将**处理机分配**给它。

进程调度是操作系统中**最基本**的一种调度，在一般的操作系统中都必须配置进程调度。
进程调度的**频率很高**，一般几十毫秒一次。



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150053987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)



## 挂起

处于挂起的进程, 处于挂起状态的进程映像在外存中

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050615002451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)



# 调度时机

## 主动放弃处理机

+ 进程正常终止
+ 进程发生异常而终止
+ 进程主动请求阻塞(如 等待I/O)

## 被动放弃处理机

+ 时间片用完
+ 更紧急的事情需要处理
+ 更高优先级的进程进入就绪队列

## 不能调度的时机

+ **中断处理**的时候
+ 在操作系统**内核程序临界区**
+ **原子操作**过程中



+ 临界资源: 一个时间段内只允许一个进程使用的资源, 各进程要**互斥**地访问临界资源
+ 临界区: 访问临界资源的那段代码
+ 内核程序临界区:  用来访问某种内核数据结构, 如进程的就绪队列



# 调度方式

### 非抢占式

非剥夺调度方式, 只允许进程主动放弃处理机, 实现简单, 开销小, 但是无法及时处理紧急任务，适合于早期的批处理系统

### 抢占式

当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。



+ “狭义的进程调度”与“进程切换”的区别：

  + 狭义的进程调度指的是从就绪队列中**选中一个要运行的进程**。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）

  + 进程切换是指一个进程**让出处理机**，由另一个进程**占用处理机**的过程。

+ 广义的进程调度包含了选择一个进程和进程切换两个步骤。
  进程切换的过程主要完成了：

  1. 对原来运行进程各种数据的保存

  2. 对新的进程各种数据的恢复
     （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

+ 注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。



# 调度算法

+ 评价指标
  + CPU使用率: CPU处于忙状态所占时间的百分比
  + 吞吐量: 在单位时间内完成的进程数量
  + 周转时间: 一个进程从初始化到结束,包括所有等待时间所花费的时间
  + 等待时间: 进程在就绪队列中的总时间
  + 响应时间: 从一个请求被提交到产生第一次相应所花费的总时间
  + 各指标在操作系统上的表现:
  + 低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)
  + 操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)
  + 吞吐量是操作系统的计算带宽
  + 响应时间是操作系统的计算延迟

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150344160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70)