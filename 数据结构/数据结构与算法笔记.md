# 排序算法

## 十大排序总览

![img](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

+ `k`为桶个数



## 1. 冒泡排序Bubble

+ 比较相邻元素, 如果顺序错误则交换位置. 
+ 第`i`次排序后, 第`n-i`个元素一定在正确的位置
+ 只需要排序`n-1`次
+ 时间复杂度`O(n^2)`
+ 空间复杂度`O(1)`



## 2. 选择排序Selection

+ 第`i`次循环从第`i-1`个元素开始, 维护一个`int min`, 选出当前最小的元素序号, 跟第`i-1`位交换
+ 需要排序`n-1`次
+ 时间复杂度`O(n^2)`
+ 空间复杂度`O(1)`



## 3. 原地: 插入排序Insertion

+ 将当前元素倒序遍历, 跟已排序的数比较, 每次
+ 第一种方法: 如果顺序错误, 交换; 顺序正确, break
+ 第二种方法: 如果遍历已排序元素`j`大于当前元素, 复制到`j+1`; 小于, 把当前元素放到`j+1`
+ 注意**索引越界异常**
+ 时间复杂度`O(n^2)`
+ 空间复杂度`O(1)`



## 4. 希尔排序Shell

+ 改进的插入排序, 先分组再插入

+ 过程: 

  1. 选定一个增长量`gap`, 进行分组, 即`i`, `i+k`, `i+2k` ... 为一组, 共`k`组
  2. 对每组进行插入排序
  3. 减小增长量, 重复第二步, 最小增长量为1 

  ```java
  int j;
  for (int gap = arr.length / 2; gap >  0; gap /= 2) {
      for (int i = gap; i < arr.length; i++) {
          Comparable tmp = arr[i];
          for (j = i; j >= gap && tmp.compareTo(arr[j - gap]) < 0; j -= gap) {
              arr[j] = arr[j - gap];
          }
          arr[j] = tmp;
      }
  }
  ```

  

+ `gap`的选择:

  ```java
  int gap = 1;
  while(gap < len / 2){
      gap = 2gap + 1;
  }
  
  // 每次gap的变化
  gap /= 2;
  ```

  

## 5. 归并排序Merge

+ 先**递归**对半分组, 一直分到长度为1 为止

+ 然后归并, 将对半分的两组合并, 每次选出一个较小的元素加入**临时数组**, 直到所有元素都加入为止, 然后将临时数组拷贝回原数组

+ ```java
  static void mergeSort(int[] arr){
      int len = arr.length;
      int[] tmp = new int[len];
      sort(arr, 0, len-1, tmp);
  }
  void sort(int[] arr, int l, int r, int[] tmp){
      if(l < r){
          int mid = l + (r - l) / 2; 	//对半分组
          sort(arr, l, mid, tmp);		//递归各自排序
          sort(arr, mid+1, r, tmp);	
          merge(arr, l, mid, r, tmp);	//合并, 递交给上一层
      }
  }
  void merge(int[] arr, int l, int mid, int r, int[] tmp){
      int i = l, j = mid + 1;
      while(i <= mid && j <= r){ 		//比较左右数组最前面, 小的那个填充进tmp数组
          if(arr[i] <= arr[j]){
              tmp[l++] = arr[i++];
          }else{
              tmp[l++] = arr[j++];
          }
      }
      while(i <= mid){				//把左右数组剩余部分填充进去
          tmp[l++]= arr[i++];
      }
      while(j <= r){
          tmp[l++]= arr[j++];			//把tmp复制进原数组
      }
  }
  
  ```





## 6. 快速排序Quick

+ 步骤:

  1. 以第一个数为基准

  ```java
  public static void so(int[] input, int low, int high){
      if(low >= high) {
          return;
      }
      int l = low + 1;							//以第一个数low为基准,排序后面的数
      int r = high;
      int target = input[low];
      while(l < r){
          while(r > l && input[r] >= target){
              r--;								//右指针移到比基准小的数,没有则移到l
          }
          while(r > l && input[l] <= target){
              l++;								//左指针移到比基准大的数,没有则移到r
          }
          if(input[l] > input[r]){				//交换位置,使大的在右边
              int tmp = input[l];
              input[l] = input[r];
              input[r] = tmp;
          }
      }
      if(target > input[l]){				//右指针先动,如果有比基准小的数,肯定在此相遇
      input[low] = input[l];				//把基准值换到相遇处
      input[l] = target;
      }
      so(input, low, l-1);				//递归解决左右两边,
      so(input, l+1, high);
  }
  ```




## 7. 堆排序

+ 步骤: 
  1. 对所有**非叶子节点**进行下沉(`(n-1)/2` ~ `0`, 逆序), 将原数组变为大根堆
  2. 把根和待排序区最后一个元素交换位置, 重新整理待排序区
  3. 重复2步骤, 直至全部排序



## 8. 桶排序

+ **非比较排序**, 适用特殊情况
+ 步骤
  1. 先遍历整个数组, 确定最大最小值, 再分隔成数个桶, 每个桶对应一定范围
  2. 遍历数组, 每个元素放入对应范围的桶内
  3. 每个桶里进行单独排序, 再挨个输出
+ 桶排序很少单独用, 因为: 
  1. 每个桶元素个数不确定, 难以使用数组实现, 用ArrayList扩容会带来额外损失, 用链表则排序困难, **时间空间无法很好协调**



## 9. 基数排序

+ 思想: **多关键字**的桶排序, **非比较性**
+ 步骤: 
  1. 首先按个位数排序, 个位数相同的放在一个桶里, 依序放回原数组
  2. 然后按十位数排序, 放回原数组
  3. 以此类推, 直到排完最后一位数位置(按最长的一个数排, 不足则补0)
+ 稳定排序
+ 每一位可以按照计数排序的方法实现, 其排序关键字为该位的一个数



## 10. 计数排序

+ 桶思想的一种, **非比较性排序**, 适用于**数据量大, 范围小**的情况(年龄排序)
+ 步骤: 
  1. 创建一个新的数组`count`用来计数, 数组长度是确定的
  2. 从待排序元素中遍历, 遍历到一个元素, 就把计数数组对应索引的值加1
  3. 遍历完后, 在输出数组中按个数添加元素
+ 注意事项: 
  1. 如果取的范围不是从0开始, 下标需要做对应
  2. 如果保存的是对象, 为了保证**稳定性**, 可以使用**累加数组**

### 累加数组

+ 对`count`数组, 进行`count[i] += count[i-1]`, 得到累加数组
+ 累加数组记录的是: 每一个下标值, 对应的最后一个元素, 应该放在哪个位置(如`count[2] == 7`, 代表值为`2`的最后一个元素放在第`6`位)
+ 计数完毕后, 进行**倒序插入**: 倒序遍历原元素列表, 每个元素依照其值插入至`count[i] - 1`处



# 线性表

## 顺序表

+ 用地址连续的存储单元, 依次存储表中各个元素

+ 让自定义类实现`foreach`遍历: 

  + 让类实现`Iterable`接口
  + 重写`iterator()`方法

  + 创建内部类来提供`Iterator`实例

    + 内部类实现`Iterator`接口

    + 内部类重写`hasNext()`, `next()`方法

    + ```java
      @Override
      public Iterator<T> iterator(){
          return new SIterator;
      }
      private class SIterator implements Iterator{
          private int cusor; //指针, 用来遍历原数组
          public SIterator(){
              this.cusor = 0;
          }
          
          @Override
          public boolean hasNext(){ //用来判断有没有下一个元素
              return cursor < N;
          }
          
          @Override
          public Object next(){ //用来获取下一个元素
              return eles[cursor++];
          }
      }
      //数组类型强转
      arr = (T[]) new Object[length];
      ```

### 顺序表扩容

+ 扩容规则: 如果不能容纳新元素, 创建一个新数组, 长度为原数组的2倍, 拷贝所有元素
+ 缩容规则: 如果元素数量不足数组容量的1/4, 创建一个新数组, 容量是原数组的1/2



### ArrayList实现

+ 底层实现是数组
+ 比较臃肿



## 链表

### LinkedList实现

+ 底层是双向链表
+ 没有哑巴节点
+ 时间复杂度: 
  + `get` : O(n)
  + `insert` : O(n)
  + `remove` : O(n)
  + 插入比顺序表快, 查找比顺序表慢



### 约瑟夫问题

+ 内容: 循环链表,  一共n个节点, 每数m个节点便删除, 从下一个重新计数, 求最后一个人. 
+ 数学解法: 
  + 当前轮删除的节点序号为`n % m`, 剩下的最后一个节点为`f(n, m)`
  + 使用递归, 求出删除一个数字后, 剩下的最后一个节点`f(n-1, m)`, 记为`x`
  + 由于删除一个数字后的起始序号0, 对应删除前的序号, 应为`n % m + 1`, 删除一个, 再后推x个, 最终保留的序号为`(n % m + x) % m`



# 树

## 二叉树

### 满二叉树

每一层节点个数都达到最大(2^n个). 

### 完全二叉树

满二叉树删去若干个节点, 每次都从最下一层的最右边删, 形成完全二叉树. 



## 平衡树

+ 最坏情况下, 二叉查找树会变成链表: 插入数据单调, 每次插入都只在同一边



### 2-3查找树

+ 具有两种节点, 2-结点和3-结点
  + 2-结点含有一个键(及对应值)和两条链, 左连接的键都小于该节点, 右链接都大于该节点
  + 3-结点有两个键和三条链, 左链的键都小于该节点, 中链的键位于该节点两个链之间, 右链大于该结点
+ 插入
  + 如果查到最后的节点是一个2-结点, 则插入其中, 变成3-结点
  + 如果树只含有一个3-节点, 无父节点, 则先插入结点中, 变成一个4-结点, 再把位于中间的数提升成为根节点, 左边的键作为左结点, 右边的键作为右结点
  + 如果最终查到3-结点, 父节点是2-结点: 先转化为4-结点, 然后把中间的键提升到父节点, 父节点变为3-结点
  + 如果最终查到3-结点, 父节点也是3-节点: 先转为4-节点, 然后提升中间的数, 然后父节点转为4-结点, 以此类推
+ 性质
  1. 任意空链接到根的路径长度相等
  2. 只有根节点分解时, 树高度才+1
  3. 普通二叉树是自顶向下生长, 而2-3树是自底向上生长



## 红黑树

+ 两种链接: 

  + **红链接**: 两个2-节点连起来, 构成3-结点. 相当于把3-结点表示为一个左斜的红色链接

    父子结点直接的链接为红色, 则子节点为红节点

  + **黑链接**: 普通链接

+ 定义

  1. 红链接都是左连接: 当前节点向左分支, 形成3-结点
  2. 没有任何一个节点同时和两个**红链接**相连(否则形成4-节点)
  3. 该数黑色平衡, 即任意空链接到根节点的**黑链接**数量相同

### 平衡:

+ 左旋: 如果红链接出现在父节点的右边, 则左旋: 

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1627028019178-1627028019150.png)

+ 右旋: 如果父节点的左子节点, 左子节点的左子节点都为红色(连续两个红节点), 则右旋(旋转后仍不平衡, 需后续操作)

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1627028089447-1627028089435.png)

### 插入

![img](https://upload-images.jianshu.io/upload_images/2392382-fa2b78271263d2c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1033/format/webp)

1. 向一颗只含有一个2-节点的红黑树中插入
   + 如果新键小于当前节点, 插在左边作为红节点, 共同组成3-节点
   + 如果新键大于当前节点, 插在右边作为红节点, 并**左旋**, 让新节点成为父节点
2. 向底部的2-节点中插入
   + 同上, 新节点也作为红节点
3. 颜色反转
   + 如果一个节点左右子节点都为红色: 将该节点变为红色, 所有子节点都变为黑色



## B树

+ 是对2-3树的拓展, 一个节点可以有多个Key
+ 对于一个M阶B树: 
  + 一个节点最多有M-1个key, 以**升序排列**
  + 每个结点最多M个子节点
  + 根节点至少两个子节点
+ 实际运用中, M一般比较大(大于100), 存储大量数据的时候高度也很小

### 插入

如果插入结点已满, 则让中间的数往上提升



## B+树

+ 是B树的变形, 差异在于:
  1. 非叶结点只具有索引作用, 非叶子节点只存Key, 不存Value
  2. 所有叶结点构成一个有序链表

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1627037003515-1627037003462.png)

### B+树和B树对比

+ **B+树的优点**: 

  1. B+树的非叶子节点不存数据, 因此在内存相同的情况下能存更多Key
  2. 遍历B+树只需要线性遍历叶子结点, 而遍历B树需要递归

+ B树的优点: B树每个结点又有Key又有value, 因此只需要找到Key就行, 在B+中要一直找到最底层

+ B树的实现: 文件系统

  B+树的实现: 数据库索引



# 堆

## 堆的特性

1. 堆是一个**完全二叉树**
2. 通常**用数组实现**, 存储方式是广度优先遍历, **从1开始**存, `i`号的左子树是`2i`号, 父结点是`i/2`
3. 每个结点都大于等于子节点(大根堆), 子节点之间大小不确定

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1626959015952-1626959015918.png)



+ 添加节点: 
  + 先加到末尾
  + 使用上浮`swim()`方法, 不断比较新节点与父节点`k/2`的大小关系, 如果比父节点大, 则交换位置, 继续向上比较
+ 删除最大节点
  + 把最末尾节点换到根节点
  + 使用下沉`sink()`方法, 与子节点`2k, 2k+1`中较大者比较, 如果比子节点小, 则交换位置, 继续向下比较



+ 3. 



## 优先队列

使用堆实现, 取出时类似于堆排序的步骤2



## 索引优先队列

+ 优先队列不能访问任意索引的元素, 只能访问头元素. 
+ 为了解决这一问题, 引入索引优先队列
+ 具体实现原理: 
  + 引入**无序辅助数组** `item`, 存入具体数据, `item`的索引对应一个具体数值(键-值)
  + 堆数组`pq`中存储的是辅助数组索引(键)
  + 每次更改数据, 按照数据对堆进行调整
  + 更改数据时, 需要对`pq`数组进行遍历, 效率低
    + 为了解决这个问题, 添加另一个辅助数组`qp`
    + `qp`把`pq`的元素作为索引, 把索引作为元素, `qp`索引和`item`索引一致
    + 给出需要修改的元素索引时, 根据`qp`查出`pq`的索引, 然后直接修改



# 并查集

+ 并查集可以快速实现如下操作: 
  1. 查询元素p和q是否在同一组
  2. 合并元素p和q所在的组





## 实现

+ 并查集也是一个树形结构, 但要求很简单

  1. 每个元素对应一个结点
  2. 每组数据中多个元素在同一树中
  3. 一个组对应的树和另一个组对应的树没有任何联系
  4. 元素在树中没有父子关系的硬性要求

+ 并查集的实现是**数组**, 使用UF-Tree方法, 构造一个数组`int[] f`, 数组的索引代表元素的索引即一个结点, 数组存储该结点的**父结点**或自身(如果自身就是根节点). 

+ **查询**`find(int i)`: 

  查询`i`所在组时, 先查`f[i]`, 如果`f[i] == i`则查询结束, 组长为`i`; 反之, 继续递归查询`f[f[i]]`, 直到`f[j] == j`, 表明到了根部

+ **连接**`union(int a, int b)`: 

  查询到`a, b`的根节点, 然后让其中一个根节点指向另一个根节点



### 路径压缩

+ UF_TREE Weighted : 有权重的树
+ 添加一个`sz[]`数组, 记录每个树中元素个数, 只在根节点处记录就行

+ 每次都把小树合并到大树上
+ 即边查边改





# 普利姆/克鲁斯卡尔/迪杰斯特拉算法

## 普利姆算法

+ 解决最小生成树问题: `n`个节点的**加权无向图**, 用`n-1`条边将他们全部连接, 且边的总权重最小
+ 思路: 
  1. 从任意一个点`A`出发, 选择与它相连的权重最小的边`A - B`, 把`B`也加入节点列表
  2. 从`A B`同时出发, 选择权重最小的边`B - C`, 把`C`加入列表
  3. 以此类推, 知道把所有点加入列表



## 克鲁斯卡尔算法

+ 同样解决最小生成树问题
+ 思路: 
  1. 把所有边按照权重从小到大排序
  2. 选择权重最小的边, 连接
  3. 一直选择边连接, 直到所有点都连接
     + 要求: 在**不产生回路**的前提下, 每次都选择权重最小的边
     + 判断是否产生回路: 每个点都设置当前连接的终点(如: 与它相连的序号最大的点), 如果两个点的终点相同, 则不能再相连



## 迪杰斯特拉算法(路由算法)

+ 解决问题: **最短路径算法**在加权有向图中, 从一个源点出发, 到其他点的最短路径

+ 核心思想: **广度**优先算法

+ 步骤: 

  1. 设置出发点`v`, 顶点集合`{v1, v2...}`, `V`到各顶点的距离集合`Dis{d1, d2...}`(到自身可看作0), 记录`v`到`vi`的最短路径; 点集合`S`, 记录已经确认最短路径的点及对应的距离(初始点对应距离为0)

     初始状态下, `Dis`中与起点直接相连的点距离是边的权重, 不相连的店距离是**无限大**

  2. 从`Dis`选出距离最近的值`di`, 把对应的点`vi`加入`S`, 更新`Dis`(只需要更新与新加入`vi`直接相连的点)

     之所以确认已找到`vi`最近距离, 是因为: 如果当前集合到各点的距离中, 到`vi`的距离`di`最短, 则不可能找到另一条中转路线`-vk -xxx -vi`使得距离更短, 因为`dk > di`且其他距离不为负数

  3. 重复第2步, 直到目标点`vx`加入`S`中
