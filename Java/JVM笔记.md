# JVM内存模型

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1628255197274-1628255197182.png)

+ 堆是管路内存最大的一块, 线程共享, new的对象**大部分**在堆里
+ 虚拟机栈是第二大的一块, 是线程私有的, 里面有局部变量表
  + 每增加一个线程, 会立刻为线程开辟一个栈空间
  + 每个栈空间里会开辟一个`main`方法的**栈帧**, main在最底下
  + 每运行一个方法都有自己的**栈帧**
  + 栈帧遵循**先进后出**(栈的特性)

# JVM的位置

+ 运行在操作系统上(Windows, Linux), 再往下是硬件



# JVM体系结构

+ `.java`文件 ---> 编译为`.class`文件 ---> 通过**类装载器**`Class Loader`装载进JVM, 称为运行时数据区(Runtime Data Area)
+ ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1628259097212-1628259097184.png)

## 运行时数据区(Runtime Data Area)

结构看最上面的图

+ 方法区
+ Java栈
  + 栈没有垃圾, 否则方法无法弹出, 程序死亡
+ 本地方法栈
  + 下连本地方法接口(Native Method Interface **JNI**)
    + 下连本地方法库
+ 堆
+ 程序计数器



# 类加载器

+ 作用: 加载CLASS文件 
+ 类是一个模板, 是抽象的, 对象是具体的

1. class文件通过类加载器**加载进JVM**, 成为一个class对象(模板);

2. 模板通过**实例化**`new`, 可以得到该类的实例
   + 该对象的引用地址(名字)在栈里, 实际内容存储在堆里
3. 实例通过`getClass()`, 可以得到模板的class对象
4. class对象通过`getClassLoader()`, 可以得到加载该Class文件的类加载器



## 类加载器分类

1. 虚拟机自带加载器
2. 启动类(根)加载器 (Bootstrap ClassLoader) : 负责**JRE核心类库**, 如`lib`目录下的`rt.jar` , `charsets.jar`等
3. 扩展类加载器(Extension ClassLoader) : 主要加载`JAVA_HOME/lib/ext`目录中的类库
4. 应用程序加载器(App ClassLoader) : 加载用户路径下的类包
5. 用户自定义加载器(User ClassLoader) : 加载用户自定义路径下的类包





# 双亲委派机制

+ 目的: 为了保证安全. 如果想要替换系统级别的类, 会失败
+ 具体内容: 
  1. 一个类想要加载时, 类加载器会查找**是否加载过该类**
     1. 如果**加载过**则不加载该类
     2. 如果**没有**加载过, 则**递归**地向上查找, **父加载器**是否加载过该类
  2. 如果一直查找到**启动类加载器**, 仍**没有被加载过**, 再往上查找加载器为`null` , 则查找是否可以由当前加载器加载该类
     1. 如果当前加载器可以加载该类, 则由当前加载器加载
     2. 如果不能加载, 则**递归**地向下查找, **子加载器**是否可以加载该类
     3. 如果一直找不到, 最终会报`ClassNotFoundException` . 





# 沙箱安全机制

+ Java安全模型的核心就是沙箱(sandbox)
+ 沙箱主要限制系统资源访问, 如CPU / 内存 / 文件系统 / 网络
+ 不同代码会被加载到不同运行空间, 可实现差异化的代码执行权限控制

+ 沙箱基本组件

  + **字节码校验器( bytecode verifier )** : 确保Java类文件遵循 Java语言规范

  + **类装载器( class loader )** : 在三个方面对Java沙箱起作用
    1. 防止恶意代码干涉善意代码 : 双亲委派机制
    2. 守护被信任的类库边界 : 双亲委派机制
    3. 将代码归入保护域, 确定了代码可以进行哪些操作 : 沙箱机制, 自己写的代码不能调C的库





# Native(重要)

+ 凡是带了`native`关键字, 说明java作用范围达不到, 需要调用底层c语言的库
+ 带Native的方法会进入**本地方法栈**, 调用**本地方法接口 `JNI`** 
  + 如Tread类中的`start0()`
+ `JNI`作用: 扩展Java使用, 融合不同编程语言为Java所用, 最初: C / C++用的较多, 需要支持
+ `JNI` 在内存区域中开辟了标记区域: `Native Method Stack`本地方法栈, 在最终执行的时候,通过`JNI`, 加载本地方法库的方法
+ 可用于驱动硬件等
+ 调用其他接口: socket , webservice 





# PC寄存器

+ 程序计数器: Program Counter Register
+ 每个线程有一个程序计数器, 是**线程私有**的, 指向方法区中方法字节码(用来存储指向下一条指令的地址), 在**执行引擎**读取下一条指令, 占地**非常小**, 不会发生OOM
+ 如果线程运行的是本地方法, 则计数器中的值是`undefined`





# 方法区

+ 所有程序共享
+ 方法区是被所有线程共享,所有字段和方法字节码,以及一些特殊方法,如构造函数,接口代码也在此定义, 简单说,所有定义的方法的信息都保存在该区域,此区域属于共享区间;

+ **static, final, Class模板, 运行时常量池**放在方法区
+ Class文件常量池:
  + 存放**编译期生成的**各种字面量和符号引用
  + **字面量:** 
    + 文本字符串
    + `static`修饰的变量
  + **符号引用:** 
    + 类和接口的全限定名, 如`java/lang/String`
    + 字段的名称和描述符: 字段就是类或者接口中声明的变量，包括类级别变量（static)和实例级的变量。
    + 方法的名称和描述符: 所谓描述符就相当于方法的**参数类型+返回值类型**
+ 字符串常量池: 
  + 永久代时, 字符串常量池**在永久代中**, 永久代逻辑上在堆中, 实际上分开, 在运行时数据区
  + 元空间时, 字符串常量池在**堆中**, 元空间在堆外的内存中
  + 使用**new**创建字符的时候, **一定会在堆中**创建一个字符串对象, 并且把堆中地址赋给变量, **可能**会在常量池中创建(如果池中没有)
  + 使用**字面量**创建时, 检查常量池, 如果没有则创建, 有则直接赋
  + 使用**+号**创建字符串, 会在编译期优化, 只创建拼接后的字符串
    + **String a = new String("1"+"2")** : 创建2个对象, 常量池"12", 堆"12"
    + **String str="a"+"b"+"c"** : 只创建1个对象, 常量池"abc"
    + **String str2 = new String("ABC") + "ABC"** : 创建3个对象, 常量池"ABC", 堆"ABC", 常量池"ABCABC"
+ 具体实现:
  + JDK1.7 及以前: 永久代 ; 
  + JDK1.8 : 元空间
+ 逻辑上是堆的一部分, 实际上不用GC和压缩, 看做独立于堆的内存空间
+ 方法区大小决定了系统可以保存多少个类, 如果类太多会导致方法区溢出, 报OOM: PermGen space(永久代)或Metaspace(元空间)
  + 加载大量jar包
  + Tomcat部署的工程过多
  + 大量动态生成反射类
+ 元空间不在虚拟机设置的内存中, 而是使用本地内存(==本质区别==), 内部结构也有区别



## 重要

+ 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中,但是实例变量存在堆内存
  中,和方法区无关





# 栈

+ 栈内存: 主管程序的运行, 生命周期和线程同步
+ 一旦线程结束, 栈内存就释放
+ 栈存放的内容: 8大基本类型, 对象引用地址, 实例的方法
+ 栈运行原理: 栈帧
  + 栈帧存放的内容: 
    + 方法索引
    + 输入输出参数
    + 本地变量
    + Class File(引用)
    + 父帧(靠底)
    + 子帧(靠顶)
  + 每执行一个方法, 产生一个栈帧
+ 栈**可能**会报OOM ! : 如果栈允许扩容, 扩容时可能报OOM, 但**HotSpot不允许栈扩容**





# 三种JVM

+ Sun HotSpot
+ BEA JROKit
+ IBM J9 VM





# 堆

+ Heap, **一个JVM只有一个堆**, 大小可调节
  + 堆里可以划分线程私有缓冲区(Thread Local Allocation Buffer, TLAB)
+ 堆的内存空间, 物理上可以不连续, 逻辑上连续
+ 类加载器读取类文件后, 会把**类, 方法, 常量, 变量**保存到堆中.
+ 堆会保存所有引用类型的**真实对象**
+ 堆内存细分为三个区域: 
  + 年轻代
  + 老年代
  + 永久区



# 新生区 老年区

## 新生区

+ 分为伊甸园区 (Eden), 幸存0区 (survive to), 幸存1区 (survive from)区, 8 : 1 : 1

1. 一个类刚被创建出来时放在Eden区, 如果Eden区**放不下**, 会触发一次**轻GC(Minor GC / Young GC)**, 进行可达性分析, 还存在引用的会活下来, 放入幸存者0区(此前两个都空), 将年龄设为1, 然后将**新对象放在Eden**
   + 如果YGC之后Eden还是放不下, 直接放进老年区
   + 如果老年区也放不下, FGC
   + 如果FGC后还是放不下, OOM
2. 新对象继续放Eden, 如果Eden区又满了, 则再进行轻GC, 并且**S0区的也要进行判断**, 合格的都放在S1区, 年龄+1
   + 每次都放在to区, 谁空谁是to
3. 如果年龄达到阈值(MaxTenuringThreshold)(默认15), 晋升(promotion)进入老年区, 此后年龄计数器不管用了
   + survive to区放不下, **不会**触发轻GC, 直接**晋升老年代**





# 永久区

+ 该区域常驻内存, 用来存放JDK自带的Class对象, Interface元数据, 存储Java运行时的一些环境或类信息, 不存在垃圾回收, 关闭虚拟机会释放该区域内存
  + 1.6之前 : 永久代, 常量池在**方法区**
  + 1.7  : 永久代, 退化, 去永久代, 常量池在堆中
  + 1.8之后 : 无永久代, 常量池在**元空间**







# 堆内存调优

+ 初始化内存默认为系统内存的1/4, 总内存默认为系统内存的1/64
+ 调整语句(VM options中设置, 不同语句之间空格隔开, 语句中间不能有空格):
  + 初始化内存: `-Xms1024m`
  + 总内存: `-Xmx1024m`
  + 打印GC详情: `-XX:+PrintGCDetails`
+ 堆内存调优: 如果遇到OOM
  1. 尝试扩大堆内存, 看结果
  2. 如果还报错, 分析内存, 看哪个地方出了问题
     + 具体方法: 通过内存快照分析工具MAT, Jprofiler
     + 获取dump文件: `-XX:+HeapDumpOnOutOfMemoryError`, 保存在src同级文件(把OOMError换成别的, 可以在出其他问题时生成dump)
+ MAT, Jprofiler
  + 作用:
    + 分析Dump文件, 快速定位内存泄漏
    + 获得大的对象







# Garbage Collection

+ 主要在Eden区和老年区

+ GC时, 并不是对三个区域(Eden, Survive, 老年区) 统一回收, 大部分只回收新生代
+ 部分收集 (Partial GC)：
  - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
  - 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
  - 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

+ 整堆收集 (Full GC)：收集整个 Java 堆和方法区。





## GC常用算法

常见: 标记清除法, 标记整理法(标记压缩), 复制算法, 引用计数法(几乎不用)



+ 引用计数法: 每多一次引用, 计数器+1
  + 计数器本身占用资源
  + 对象很多, 效率低
  + 不能解决互相引用的循环问题
+ 复制算法(to from): 把原有内存分为两块, 一次只使用一块. 每次GC把正在使用内容复制到另一块里, 然后清除正在使用的块
  + 新生代主要使用复制算法





# JMM







# 字符串等常量池

## 字符串常量池

+ 1.7之前放在方法区, 1.7之后放在堆中
+ 所有字面量在编译时都会放入常量池
+ new字符串时, 一定会在堆中创建一个**新字符串对象**, 并指向该对象
+ `intern()`是一个**Native**方法, 作用是检测该字符串是否在常量池中, 没有就添加, 并返回该常量池字符串的引用

+ 拼接相关: 
  + 字面量的`+`拼接,  在编译时就会完成, 并放入常量池
  + 引用的拼接, 相当于new一个对象, 并存入常量池



## 其他常量池(应用类型)

+ Double, Float没有实现常量池, 其他都实现了
+ **注意**, 如果不**涉及运算**, 比较的是引用地址, 如果涉及运算, 要拆包, 比较的是**数值**
+ Integer的常量池范围是[-128 127]