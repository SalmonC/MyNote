

# --------------------



# 第一部分 基础



# 第一章 基础知识

# 第二章 Java语言的开发环境搭建

+ **JVM**（Java VIrtual Machine）：Java**虚拟机**，Java程序的运行环境
+ **JRE**（Java Runtime Environment）：Java程序的**运行环境**，包含`JVM`和`核心类库`
+ **JDK**（Java Runtime Kit）：Java程序的**开发工具包**，包含`JRE`和开发工具

# 第三章 HelloWorld入门程序

3.1. 开发步骤说明
Java开发三步骤：**<u>编写、编译、运行</u>**。

*****

3.2 编写Java源程序

```java
public class HelloWorld{//定义一个类
    public static void main(String[] args){//程序起点
        System.out.println("Hello,World!");
    }
}
```

1. `public class`后面代表定义一个**类**的名称，**类**是Java中所有源代码的基本组织单位，即最外层{}内的内容。
2. 第二行代表程序的起点，基本不会变。
3. 注释
   + 单行注释：`//[注释内容]`本行结尾之前都是注释
   + 多行注释：

```java
/*
中间都是多行注释（区块注释）
*/
```

4.  关键字

+ 关键字特点
  + 完全小写的字母
  + 有特殊颜色

5. 标识符

+ **标识符**：指在程序中自己定义的内容，如类、方法、变量的名字  
+ **命名规则**：
  + 可以包含`英文字母`、`数字`、`$`、`_`。
  + 不能以**数字**开头
  + 不能是关键字
+ **命名规范**：
  + **类**名规范：首字母**大写**，后面每个首字母大写（大驼峰式）
  + **变量名**规范：首字母**小写**，后面每个首字母大写（小驼峰式）
  + **方法名**规范：同变量名

# 第四章 常量

+ 概念：在程序运行期间，固定不变的量
+ 分类
  1. 字符串常量：用**双引号**引起来的**任何**部分，包括数字。`”123“、”ABC“、""`
  2. 整数常量：直接写上的数字，没有小数点。`123、100`
  3. 浮点数常量：直接写上的数字，有小数点。`2.5、-3.14`
  4. 字符常量：凡是**单引号**引起来的**单个**字符。`'A'、'b'、'中'、'8'`
  5. 布尔常量：`true、false`
  6. 空常量：没有任何数据`null`
+ 数据类型
  + 基本数据类型（4类8种）
    + 整数型 byte short int long
    + 浮点型 float double
    + 字符型 char
    + 布尔型 boolean
  + 引用数据类型：字符串、数组、类、接口、Lambda
  + 注意事项
    1. 字符串不是基本类型，是引用类型
    2. 浮点型可能只是近似值，并非精确值
    3. 数据范围与字节数不一定相关
    4. 浮点数默认类型是double，一定要使用float，要加上后缀F。  
       如果是整数，默认为int，如果一定要用long，需要加上后缀L。

# 第五章 变量

+ 变量：程序运行期间，内容可以发生改变的量。
+ 创建并使用格式

```java
数据类型 变量名称;//创建一个变量
变量名称 = 数据值;//赋值，注意，给long赋值需要最后加L
或
数据类型 变量名称 = 数据值
```

+ 注意事项
  1. 创建多个变量，变量之间的名称不可以重复。
  2. 对于float和long类型，字母后缀F或L不可舍弃。
  3. 右侧数据值范围不能超过左侧类型的范围。
  4. 变量需要先赋值再使用。
  5. 变量使用不能超过作用域的范围。【作用域】：从定义变量开始，一直到**直接所属的大括号**结束为止。
  6. 可通过一个语句创建多个变量，但不推荐这样写

```java
int a,b,c;
a = 10;
b = 20;
c = 30
int x = 100, y = 200, z = 300
```

# 第六章 数据类型转换

+ 数据类型不同时，将发生数据类型转换
+ 自动类型转换（隐式）
  1. 特点：不需要特殊处理，自动完成
  2. 规则：数据类型从小到大（如：`int`到`long`）
+ 强制类型显示（显式）
  1. 特点：代码需要进行特殊的格式处理，不能自动完成
  2. 格式：范围小的类型 变量名 = （范围小的类型） 范围大的数据

```java
int num = (int) 100L;
```

+ 注意事项
  1. 强制转换一般不推荐使用，因为可能发生精度损失、数据溢出。
  2. byte、short、char三种类型都可以进行数学运算。
  3. byte、short、char三种类型运算时会先被提升成为int类型。
  4. boolean类型不能发生数据类型转换，与其他语言不一样。

```java
byte num1 = 40;
byte num2 = 50;
byte result1 = num4 + num5; //此处报错，运算时变为int，转换为int时需强制转换。
byte result2 = (byte) num4 + num5;//逻辑上不溢出即可
```

+ ASCII码（音ask）

  + >只需要记住*48 = '0', 65 = 'A', 97 = 'a'*。

# 第七章 运算符

+ 运算符：进行特定操作的符号

  + 加：
  + 减：-
  + 乘：*
  + 除：/（整数运算得到整数）
  + 取模：%（只对整数有意义）`10 % 3 = 1`

+ 表达式：运算符连起来的式子 

+ +号的3种常见用法

  + 对于数值，就是加法
  + 对于字符`char`，会先被提升为`int`再计算，参照ASCII、Unicode。
  + 对于字符串String来说，` + `代表字符串连接。任何数据类型和String连接都会变成字符串。

+ 自增自减运算符

  + 自增运算符：++
  + 自减运算符：--
  + 基本含义：让一个变量涨一个或者降一个数字1
  + 使用格式：放在**变量名**之前或之后。如`++num`或者`num++`
  + 使用方式：
    1. 单独使用，不和其他操作混合，自己独立成为一个步骤。
    2. 混合使用：和其他操作混合，例如与复制混合等。
   + 使用区别：

      1. 单独使用时++在前灾后没有任何区别。
      2. 混合使用时,有**重大区 别**：

      + 前++：变量立刻+1，并且使用结果【先加后用】；
      + 后++：先使用变量，后+1【先用后加】。

+ 赋值运算符

  + 基本赋值运算符： `=`。
  + 复合赋值运算符：
    + +=
    + -=
    + *=
    + /=
    + %=

+ 比较运算符：

  + 包括：`==、!=、>、<、>=、<=`
  + 运算结果：boolean值

+ 逻辑运算符

  + 与：`true && false`
  + 或：`true || false`
  + 非：`!true`
  + `&&`、`||`具有短路功能，如果左边已经可以判断最终结果，则右边代码不再执行。

+ 三元运算符

  + 一元运算符：只需要一个数据就可操作。如`!`、`++`、`--`

  + 二元运算符：需要两个数据才可以进行操作。

  + 三元运算符：需要三个数据才可以进行操作。

    + 格式：  
      数据类型 变量名称 = 条件判断 ？ 表达式A ： 表达式B  

    ```java
    int max = a > b ? a : b;
    ```

    流程：  
    首先判断条件是否成立：  

      + 如果成立，将a的值赋给左边变量
      + 如果不成立，将b的值赋给左边变量
    + 注意事项
      1. 必须保证A、B数据类型都符合左侧要求。
      2. 三元运算的结果必须被使用。

# 第八章 方法入门

+ 概念  
+ 定义格式：
  + 命名使用小驼峰式
  + 定义的先后顺序无所谓
  + 定义不能产生嵌套关系
  + 方法定义后不会执行，除非调用
  + 参数：进入方法的数据
  + 返回值：从方法中出来的数据
  + 定义的完整格式：

```java
修饰符 返回值类型 方法名称(参数类型 参数名称, ...){ 
    方法体;
    return 返回值;
  }
```

+ 内容解释：
  + 修饰符：现阶段固定public static
  + 返回值类型：最终产生的数据结果是什么类型
  + 方法名称：小驼峰
  + 参数类型：进入方法的数据是什么类型
  + 参数名称：进入方法的数据对应的变量名称
  + PS：如果参数有多个，用逗号分隔
  + 方法体：方法要做的事情
  + return：①停止当前方法，②将后面的结果数据返回值还给调用处。如果有返回值，必须写return。
  + 返回值：方法执行后最终产生的数据结果
  + 注意return后面的返回值必须和方法名称前面的返回值类型保持对应
 + 调用格式：
   + 单独调用：方法名称（参数）
   + 打印调用：println(方法名称(参数))
   + 赋值调用：数据类型 变量名称 = 方法名称(参数)
   + 注意：此前学习的方法返回值类型固定写为void，这种方法无返回值，只能单独调用。不能写return 返回值，可以写return自己。
   + 一个方法可以有多个return，但要保证同一时间只有一个能被执行。

```java
方法名称();
```

+ 编译器的常量优化：常量运算时自动进行强制转换，有变量时不能进行。
+ 方法的重载（OverLoad）
  + 概念：多个方法的名称一样，但参数列表不同
  + 好处：只需要记住其中一个方法的名称
  + 重载与下列因素相关：
    1. 参数个数不同
    2. 参数类型不同
    3. 参数多类型顺序不同
  + 重载与下列因素无关：
    1. 参数名称
    2. 方法返回值类型
    3. 修饰符

# 第九章 流程控制

## 1. 顺序结构：从上到下依次运行

----------

## 2. 选择结构（判断语句）

### 2.1 if结构

+ if语句第一种格式：if 

```java
if(关系表达式){
  语句体；//为true，则执行；反之不执行
}
```

### 2.2 if... else结构

+ if语句第二种格式： if...else

```java
if(判断条件1){
  语句体1；
/*
}else if(判断条件2){
  语句体2
*/
}else{
  语句体3；
}
```

------

## 3. 选择语句--switch

+ switch语句格式

```java
switch(表达式1){
  case 常量值1：
    语句体1；
    break；//遇见break，整个switch结束
  case 常量值2：
    语句体2
    break；
  ...
  default：//负责收尾，全都不匹配
    语句体n+1；
    break；//最好不要省略最后一个break
}
```

+ 注意事项：
  + 多个case的值不可以相同
  + switch小括号中只能是下列数据类型：  
    基本：byte/short/char/int；引用：string/enum（枚举）
  + switch格式可以很灵活：前后顺序可以颠倒（default可以不在最后），且break可以省略
+ switch的穿透
  + 匹配哪个case，就从哪里一直往下执行，***不再进行匹配***，直到遇见`break`或者整体结束

-------

## 4. 循环结构

+ 组成部分：一般分为4部分
  1. 初始化语句：在循环开始最初执行，只执行唯一一次
  2. 条件判断：成立则循环继续，否则退出
  3. 循环体：重复要做的事情内容
  4. 步进语句：每次循环之后要进行的扫尾工作

### 4.1 循环语句1--for

+ for循环语句格式：

```java
for (初始化表达式；布尔表达式；步进表达式){
  循环体;//布尔表达式为true则执行
}
//例如
for (int i = 1; i <= 100; i ++){
  System. out. println(i);
}
```

### 4.2 循环结构2--while

+ 标准格式  

```java
while(条件判断){
  循环体；
}
```

+ 扩展格式

```java
初始化语句;
while(条件判断){
  循环体;
  步进语句;
}
```

### 4.3 do...while...循环

+ **先执行**do的内容，再判断；

```java
do{
  循环体;
}while(条件判断);
```

### 4.4 三种循环的区别

1. 如果条件从来没有满足过，for和while将会执行0次，而do-while至少执行1次；
2. for循环的变量在小括号中定义，只有循环内部才可以使用；

-------

## 5. 条件控制语句

### 5.1 break

+ 常见用法
  1. 用在switch语句中，一旦执行，整个switch立刻结束；
  2. 用在循环语句中，一旦执行，整个循环语句立刻结束。

* 关于循环的选择，有一个小建议：
  * 凡是次数确定的场景，多用for循环；否则多用while。

### 5.2 continue

一旦执行，立刻跳过当次循环剩余内容，马上开始下一次循环。

-------

## 6. 死循环

+ 指永远停不下来的循环。
+ 死循环的标准格式：

```java
while(true){
  循环体;
}
```

# 第十章 数组

+ 概念：一种容器，可以同时存放多个数据。
+ 特点：
  1. 是一种引用数据类型
  2. 数组中的多个数据，类型必须统一
  3. 数组长度在程序运行期间不可改变

-------

## 数组的初始化

+ 数组的初始化：在内存中创建一个数组，并赋予一些默认值
  1. 动态初始化：指定长度
  2. 静态初始化：指定内容

+ 动态初始化数组的格式：

```java
数据类型[] 数组名称 = new 数据类型[数组长度];
/*
左侧数据类型：数组当中保存的数据都是统一的指定类型
左侧中括号：表示数组
右侧的new：表示创建数组的动作
右侧数据类型：必须和左侧一致
中括号内数组长度：数组当中可以保存多少个数据，是一个int数字
*/
```

+ 静态初始化数组的格式：

```java
//标准格式
数据类型 [] = new 数据类型 []{ 元素1, 元素2, ...}
//省略格式
数据类型 [] = { 元素1, 元素2, ...}
```

+ 注意事项
  1. 静态初始化没有直接指定长度，但仍然会自动推算得到长度。
  2. 静态、动态初始化标准格式可以拆分为两个部分：
  3. 省略格式不能拆分
  4. 使用建议：不确定数组具体内容，用动态初始化；已确定用静态。

```java
int [] a
a = new int []{1 , 2 , 3 }
```

------

## 数组的使用

+ 直接打印数组，得到的是数组对应的**内存地址哈希值**
+ 访问数组元素的格式：`数组名称[索引值]`
  + 索引值：一个int数字，代表元素编号
  + 索引值从**0**开始
+ 动态初始化数组时，元素自动拥有默认值，规则如下
  1. 整数类型，默认为0；
  2. 浮点类型：默认为0.0；
  3. 字符类型，默认为\u0000"：Unicode码0000，一个不可见字符；
  4. 布尔类型，默认为false；
  5. 引用类型，默认为null。
+ 注意事项：静态初始化也有默认值，只是立刻被替换了。
+ 数组长度
  + 获取格式`数组名称.length`
  + 数组一旦创建，程序运行期间长度不可改变。可以重新new，改变长度。
+ 遍历数组
  + 含义：对数组中每个元素进行逐.一处理。默认处理方式是打印输出。
  + 方法：用for循环，`array.fori`。
+ 数组作为方法的参数：
  + 调用方法时，向方法小括号传递的时数组的***地址值***。

```java
public static void 方法名称(int[] array){
  方法体
}
```

+ 数组作为方法的返回值：
  + 一个方法只能有0或1个返回值，如果需要返回多个数据，可以返回数组;
  + 数组作为方法的返回值时，返回的也是地址值。
  
+ 数组复制

  **`System.arraycopy(src, srcPos, dest, destPos, length)`**

  src：源数组

  srcPos：复制开始位置

  dest：目标数组

  destPos：目标数组开始位置

  length：复制的长度

  

--------

## 常见问题

1. 数组索引越界异常：  
   + 数组索引到”数组长度-1“为止，如果访问元素时索引编号并不存在，将会发生数组索引越界异常；
   + `ArrayIndexOutOFBoundsException`
   + 原因：索引编号写错了；
   + 处理方法：修改为正确索引编号。
2. 空指针异常：
   + 数值必须进行new初始化才能使用其中元素；
   + 如果只是赋值了null，没有进行new创建，将会发生空指针异常；
   + `NullPointerException`
   + 原因：忘了new
   + 处理方法：补上new

-------



# 第十一章 Java的内存划分

+ 主要分为五个部分
  1. **栈（Stack）**：存放的都是方法的局部变量，方法的运行一定要在栈当中。
     + 局部变量：方法的参数、方法{}内的变量；
     + 作用域：一旦超出作用域，立刻从栈内存中消失。
  2. **堆（Heap）**：凡是new出来的，都在堆当中。
     + 堆内存里的东西都有一个地址值，为16进制.
     + 堆内存里的数据都有默认值，规则见数组。
  3. **方法区（Method Area）**：存储.class相关信息，包含方法的信息。
  4. 本地方法栈（Native Method Stack）：与操作系统相关
  5. 寄存器（pc Register）：与CPU相关，性能很高。

----------



# --------------------



# 第二部分 面向对象



# 第一章 面向对象思想

## 1.1 面向对象思想概述

+ 两种思想：
  1. 面向过程：实现一个功能的时候，每一个具体步骤都要亲力亲为，详细处理每一个细节。
  2. 面向对象：实现一个功能的时候，不关心具体步骤，找一个已经具有该功能的部分。

---------

## 1.2 类和对象

+ 类是一组相关属性和行为的集合。
  + 属性：该事物的状态信息。
  + 行为：该事物能做什么。
+ 类是对一类事物的描述，是**抽象的**；
+ 对象是一类事物的实例，是**具体的**；
+ **类是对象的模板，对象是类的实体**。

---------

## 1.3 类的定义

+ 定义一个类——学生，其中有两个组成部分：
  1. 成员变量（属性）：姓名、年龄  
  2. 成员方法（行为）：吃饭、睡觉、学习

```java
public class Student{
  
  //成员变量
  String name;//姓名
  int age;//年龄
  
  //成员方法
  public void eat(){
    System.out.println("吃饭");//吃饭，没有static
  }
  public void sleep(){
    System.out.println("睡觉");//睡觉
  }
  public void study(){
    System.out.println("学习");//学习
  }
}
```

+ 注意事项：
  1. 成员变量时直接定义在类当中的，在方法外；
  2. 成员方法不要写`static`关键字

---------

## 1.4 类、对象的使用

+ 通常情况下，一个类不能直接使用，需要创建一个对象才能使用。
+ 对象的使用流程

1. 导包：指出需要使用的类在什么位置；

```java
//导包格式如下
import 包名称.类名称;
//和当前类属于同一个包，可以省略导包语句
```

2. 创建：

```java
//创建格式
类名称 对象名 = new 类名称();
Student stu = new Student();
```

3. 使用：分为两种情况：

```java
//使用成员变量
对象名.成员变量名
//使用成员方法
对象名.成员方法名(参数)
//总结：想用谁，就用 对象名.xx
```

-------

## 1.5 对象与方法

+ 对象可作为方法的参数
  + 对象可作为方法的参数，传递进去的也是**地址值**。
  + 任何数据类型都可作为方法的参数，***对象***作为参数传递到方法中，传递的都是地址值。
+ 对象可作为方法的返回值

-------

## 1.6 成员变量与局部变量

+ 区别  

|     种类     |    局部变量    |        成员变量        |
| :----------: | :------------: | :--------------------: |
| **定义位置** |    方法内部    |        方法外部        |
| **作用范围** |   只有方法中   |       整个类通用       |
|  **默认值**  |   没有默认值   |    默认值规则同数组    |
| 内存位置不同 |    位于栈中    |        位于堆中        |
|   生命周期   | 随着方法进出栈 | 随着对象创建、垃圾回收 |

# 第二章 封装

+ 面向对象三大特征：封装、继承、多态

-------

## 2.1 封装性

+ 封装性在Java中的体现：
  1. 方法就是一种封装
  2. 关键字`private`也是一种封装

## 2.2 `private`的用法

+ private是修饰语，放在最前面。
+ 一旦使用private进行修饰，那么本类当中仍然可以随意访问，但超出本类范围不能**直接**访问。
+ **间接**访问private成员变量，就是定义一对Getter/Setter方法，可以在方法中设置限制。
  + 必须写成`setXxx`或者`getXxx`；
  + Getter不能有参数，返回值和成员变量对应；
  + Setter不能有返回值，参数类型和成员变量对应。
  + 注意：对于基本类型的boolean值，Getter方法要写成`isXxx`

## 2.3 `this`的用法

+ 当方法的局部变量和类的成员变量重名，会根据就近原则，优先使用**局部变量**。

+ 如果需要访问**成员变量**，可使用格式`this.成员变量名`。

+ 通过谁调用的方法，谁就是`this`。

  ```java
  per.sayHello("马云");
  //per调用了sayHello，sayHello里的this指per，this.name指per.name。
  ```




# 第三章 继承性

## 3.1 基本概念

+ 继承是多态的前提。
+ 主要解决的问题是：**共性抽取**。
+ 父类/基类/超类----子类/派生类
+ 继承关系的特点：
  1. 子类可以拥有父类的“内容”；
  2. 子类可以拥有自己专有的内容。



## 3.2 格式

在继承关系中，子类就是一个父类，如：讲师就是一个员工。关系：is-a。



```java
// 定义父类格式（一个普通的类定义）
public class 父类名称{
    ...
}

// 定义子类格式
public class 子类名称 extends 父类名称{
    ...
}
```



## 3.3 访问规则

+ 子类可以访问父类成员变量，父类不可以访问子类成员变量；

+ 如果父类与子类成员变量重名，则创建子类时访问有两种方式：

  + 直接：直接通过子类对象访问成员变量：

    创建对象时等号左边是谁，就优先用谁，没有则向上找；

  + 间接：通过成员方式访问成员变量：

    该方法属于谁，就优先用谁，没有则向上找。

+ 如何区分三种变量重名问题：

  | 局部变量 | 本类的成员变量  |  父类的成员变量  |
  | :------: | :-------------: | :--------------: |
  |  直接写  | thsi.成员变量名 | super.成员变量名 |



```java
public class zi extends fu {
    int num = 20;
    
    public void method(){
        int num = 30;
        System.out.println(num); // 30
        System.out.println(this.num); // 20
        System.out.println(super.num); // 10
    }
    
}
```



## 3.4 继承方法的访问特点

+ 在父子类的继承关系当中，创建子类对象，访问成员方法的规则：

  创建的对象是谁，就优先用谁，如果没有则向上找。

+ 注意事项：

  无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。



## 3.5  重写(Override)

+ 概念：在继承关系中，方法的名称一样，参数列表也一样。

|                          | 方法名称 | 参数列表 |
| :----------------------: | :------: | :------: |
| 重写(Override)/覆盖/覆写 |   一样   |   一样   |
|      重载(Overload)      |   一样   |  不一样  |

+ 方法的覆盖重写特点：创建的是子类对象，则优先用子类。

+ 注意事项：

  1. 必须保证 父子类直接方法名称相同，参数列表也相同。在**方法**前面写上`Override`，可以检测是否重写成功，不成功则会报错。建议能写都写上。

  ```java
  	@Override
  	public void method(){
          ...
      }
  ```

  2. 子类方法的返回值必须**小于等于**父类返回值范围。

  java.lang.Object类是所有类的公共最高父类。

  3. 子类方法的权限必须大于等于父类方法的权限修饰符。

  `public >protected>(default)>private`

+ 应用场景：对于已经投入使用的类，尽量不要进行修改，推荐定义一个新的类，来重复利用其中共性内容，并且添加改动。



## 3.6 构造(Constructor)

+ 继承关系中，父子类构造方法的访问特点：

  1. 子类构造方法中有一个默认隐含的`super()`调用，所以一定是先调用的的父类构造，后执行的子类构造。
  2. 子类构造可以通过`super`关键字来调用父类重载构造。如：  

  ```java
  // 父类没有无参构造，只有：
  public Fu(int num){   
  
  }
  
  // 子类具有无参构造，但自带super()，为了避免报错，可以：
  public Zi(){
      super(10);
  }
  ```

  

  3. `super`的父类构造调用，必须是子类构造方法的**第一个语句**；

  总结：子类必须调用父类构造方法，不写则赠送`super()`，写了则用指定的调用。



## 3.7 super关键字

super关键字的用法有三种：

1. 在子类的成员方法中，范文父类的成员变量，如`super.num`；
2. 在子类的成员方法中，访问父类的成员方法，如`super.method()`;
3. 在子类的构造方法中，访问父类的构造方法，如`super()`。
   1. 我们可以在子类的构造器中显式的使用" super(形参列表)"的方式,调用父类中声明的指定的构造器
   2. " super(形参列表)"的使用,必须声明在子类构造器的首行
   3. 我们在类的构造器中,针对于"this(形参列表)"或" super(形参列表)"只能二选一,不能同时出现
   4. 在构造器的首行,没有显式的声明"this(形参列表)"或" super(形参列表)",则默认调用的是父类中空参的构造器
   5. 在类的多个构造器中,至少有一个类的构造器中使用了" super(形参列表)",调用父类中的构造器



## 3.8 this关键字

super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：

1. 在本类的成员方法中，访问本类的成员变量（**典型用法**，用于局部变量与成员变量重名时）；

2. 在本类的成员方法中，访问本类的另一个成员方法，如：

   ```java
   public void methodA(){
       ...
   }
   
   public void methodB(){
       this.methodA;
       ...
   }
   ```

3. 在本类的构造方法中，访问本类的另一个构造方法；

   注意：

   1. `this()`也必须是构造方法的第一个语句；

   2. `this()`和`super()`不能同时使用，不再赠送`super()`。

      

## 3.9 继承性的三个特点

1. Java语言是**单继承**的，即一个类的直接父类只能有一个；
2. Java语言可以**多级继承**，java.lang.Object处于最高层；

3. 一个父类可以有很多个子类



# 第四章 多态性(polymorphism/multi)

`extends`的继承或者`implements`的实现是多态性的前提。

一个对象拥有多种形态，这就是**对象的多态性**。



## 4.1多态性的体现

代码当中体现多态性，其实就是一句话：父类引用指向子类对象。

格式：

```java
父类名称 对象名 = new 子类名称();
```



## 4.2 成员变量访问

+ 访问成员变量的两种方式：

  1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找；如果父类没有定义，则不能使用（不会向下找）；

  2. 简介通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。如果子类没有重写，就是父类方法。



## 4.3 成员方法使用

+ 多态代码中，成员方法的访问规则是：

  看new的是谁，就优先用谁，没有则向上找。

+ 成员方法口诀：编译看左边，运行看右边。

  编译看左边：只能运行父类的方法，否则报错，不能编译；

  运行看右边：如果有重名方法，运行时先运行子类方法。

+ 成员变量：编译看左边，运行还看左边。



## 4.4 多态性的作用

好处：无论右边new的哪个子类对象，等号左边调用方法都不会变化。

### 对象的向上转型

+ 对象的向上转型，就是多态写法：

  ```java
  父类名称 对象名 = new 子类名称();
  ```

+ 含义：右侧创建一个子类对象，把它当做父类来看待使用。

+ 注意事项：向上转型一定是安全的。



### 对象的向下转型

+ 向上转型一定安全，但有一定弊端：

  对象一旦向上转型为父类，就无法使用子类原本特有内容。

+ 解决方案：用对象的向下转型还原。

+ 格式：

  ```java
  子类名称 对象名 = (子类名称) 父类对象
  ```

+ 含义：将父类对象还原成为**本来的**子类对象。

  ```java
  Animal animal = new Cat();
  Cat cat = (Cat) animal;
  ```

+ 注意事项：

  1. 必须保证对象本来创建的时候就是某子类，才能向下转型为该子类；

  2. 如果对象创建的时候本来不是该子类，向下转型为该子类，就会报错: `ClassCastException`。

     类似：`int num = (int) 10.5;//不行，精度损失`
     
  3. 转换后成员变量还是父类的



## 4.5 `instanceof`关键字

如何判断一个父类引用的对象，本来是什么子类？

格式：

```java
对象 instanceof 类型;//得到一个boolean结果
```





# 第五章 构造

## 5.1 构造方法(Cosntructor)

+ 构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就在调用构造方法（此前学习过程中遇到的默认是无参）。

+ 构造方法的格式：

  ```java
  public 类名称(参数类型 参数名称){
    方法体
  }
  ```

+ 注意事项：

  1. 构造方法的名称必须和所在的**类名称**完全一样，区分大小写；
  2. 构造方法**不要写**返回值类型，连`void`都不写;
  3. 构造方法不能return具体返回值；
  4. 如果没有编写任何构造方法，编译器会赠送一个，没有参数，方法体什么事情都不做；
  5. 一旦编写了至少一个构造方法，编译器不再赠送，可再写一个无参方法；
  6. 一个类可以构造多个方法，方法可以重载。

## 5.2 定义一个标准的类(Java Bean)

+ 一个标准的类通常有下面四个部分，可用`代码→生成`或者`CMD+N`快捷键构造：
  1. 所有成员变量都要使用private来私有化修饰
  2. 为每一个成员变量编写一对Getter/Setter；
  3. 编写一个无参数的构造方法
  4. 编写一个全参数的构造方法
+ 这样一个标准的类也叫做Java Bean。





# 第六章设计模式

### 设计模式

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1621586481402-1621586481301.png)

单例设计模式, 是指采取一定的方法, 保证某个类只能存在一个对象实例, 且该类只提供一个去的其对象实例的方法(创建对象的方法)

## 6.1 单例Singleton

### 单例

1. 首先将**构造器**的访问权限设置成**private**, 这样就不能在外部构造, 但在类内部仍可以产生该类对象
2. 通过调用该类的**静态方法**来访问内部创建的对象
3. 静态方法只能访问静态成员变量, 所以该类对象的**变量也必须是静态**的

### 单例的实现

+ 两种方式: 饿汉式, 懒汉式

  1. 饿汉式

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1621587628603-1621587628566.png)

  

  2. 懒汉式

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1621587946835-1621587946796.png)

+ 饿汉式/懒汉式区别

  1. 懒汉式

     好处: 延迟对象创建, 省空间

     坏处: 线程不安全

  2. 饿汉式

     好处: 天然线程安全

     坏处: 对象加载时间过长(一开始就创建对象, 导致对象加载时间长)(static一开始就会加载, 但生命周期过长)

### 应用

+ 单例模式的优点
  由于单例模式只生成一个实例,减少了系统性能开销,当一个对象的
  产生需要比较多的资源时,如读取配置、产生其他依赖对象时,则可
  以通过在应用启动时直接产生一个单例对象,然后永久驻留内存的方
  式来解决。



## 6.2 模板方法(了解)

抽象类的应用

+ 功能内部一部分实现是确定的, 一部分不确定, 可以把不确定的部分暴露出去, 让子类去实现. 



## 6.3 代理模式

+ 为其他对象提供一种代理, 以控制对这个对象的访问
+ 代理类和被代理类都要实现接口



# 第七章 注解Annotation

## 7.1 概述

+ JDK5.0增加了对元数据(MetaData)也就是注解的支持. 

+ Annotation其实就是代码里的特殊标记, 可以在编译, 类加载, 运行时被读取, 并执行响应操作. 
+ 通过注解可以嵌入一些补充信息, 通过分析工具, 开发工具和部署工具, 可以根据补充信息进行验证或者部署
+ Annotation可以像修饰符一样被使用
+ 一定程度上 框架 = 注解+反射+设计模式

## 7.2 常见Annotation

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622211020501-1622211020291.png)

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622211113984-1622211113968.png)

+ 内置的三个注解

  1. `@Override`

  2. `@Deprecated`: 表示修饰的内容已经过时了, 能用, 提示不推荐用, 建议用新的. 通常是结构危险或者有更好的选择

  3. `@SuppressWarning`: 抑制编译器警告, 让编译器警告不显示, 并写出警告内容

     ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622212434541-1622212434527.png)



## 7.3 自定义Annotation

+ 步骤

```java
// 1. 注解声明为`@interface`
public @interface xxx{
    // 2. 成员变量以无参数方法的形式声明, 方法名和返回值定义了成员的名字和类型, 称为配置参数. 类型只能是八种基本数据类型/String/Class/enum/Annotation/以上所有数据类型的数组
    // 3. 如果只有一个参数成员, 建议参数名用value
    // 4. 如果注解有成员, 使用注解时需要指明成员的值
    String[] value();
    // 5. 没有成员的, 称作标记
}

@xxx(value = "hi")
//一个成员也可以写成
@xxx("hi")
```

+ 注意: 自定义注解必须配上注解的信息处理流程(使用反射)才有意义
+ 自定义注解一般会指明两个元注解: `Retention`, `Target`. 



## 7.4 元注解Meta-Annotation

+ 元注解: 对现有注解进行解释说明的注解

+ jdk提供的四个基本元注解的使用

  1. `Retention`: 用于指定该Annotation的生命周期. 其内部包含一个`RetentionPolicy`枚举类, 使用`Retention`时必须为该value赋值:

     + SOURCE: 在源文件中有效, 被编译器抛弃, .class文件中不会存在
     + CLASS: 保留在class文件中, 但执行时不会被加载, 是默认行为, 不注释Retention时默认CLASS
     + RUNTIME: 保留在class文件中, 解释运行时会加载到内存中, 可以通过**反射**来读取

     ```java
     @Retention(RetentionPolicy.RUNTIME)
     ```

  2. `Target`: 用于指定被修饰的Annotation能用于修饰哪些程序元素, 没有指定则没有要求

     ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622215091136-1622215091086.png)

     ```java
     @Target({TYPE, FIELD, METHOD, PARAMETER})
     ```

     

  3. `Document`: 被该注解修饰的注解将被javadoc工具提取成文档. 默认情况下javadoc不包括注解. 例: `Deprecated`过时, java文档里也能看见

  4. `Inherited`: 被该注解修饰的注解, **具有继承性**. 某个类使用了Inherited的注解, 其子类也会有该注解



## JDK8新特性

+ 可重复注解: 

  ```java
  // 需要重复使用同一个注解, 传递不同参数
  // 老式写法: 新创建一个注解, 用数组形式传入原注解
  public @interface MyAnnotations{
      MyAnnotation[] value();
  }
  -----------
  @MyInnotations({"hi", "abc"})
     
      
  // jdk8之后的写法: 还是要创建MyAnnotations
  @Repeatable(MyAnnotations.class) // 两个注解的生命周期Retetion一致, 可修饰结构Target一致, Inherited一致, Document一致
  public @interface MyAnnotation{
      String[] value();
  }
  @MyAnnotation("hi")
  @MyAnnotation("abc")
  ```

+ 类型注解: 新增两种`Target`参数

  `TYPE_PARAMETER`: 表示该注解能写在类型变量的声明语句中(如泛型声明)

  `TYPE_USE`: 表示该注解能写在使用类型的任何语句中

  ```java
  // TYPE_PARAMETER
  class Generic<@MyAnnotation T>{
      ...
  }
  
  // TYPE_USE
  	public void show(){
          // 泛型类型可用
          ArrayList<@MyAnnotation String> list = new ArrayList<>();
          // 强转类型可用
          int num = (@MyAnnotation int) 10L;
      }
  ```

  









------





# --------------------



# 第三部分 API



# 第一章 API

## 概述

API(Application Programming Interface)，应用程序编程接口。Java API是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们只需要学习如何使用。

## 使用

打开JDK API文件，在索引中搜索想看的*类*，点击后主要查看3个内容：

1. 所在的包路径，写在标题上方；
2. 构造方法；
3. 方法摘要。



# 第二章 Scanner类

## 2.1 什么是Scanner类

一个可以解析基本类型和字符串的简单文本扫描器。可以实现键盘输入数据到程序当中。

## 2.2 引用类型的使用

+ 一般步骤：

  1. 第一步：导包
     如果需要使用的目标类和当前类位于同一个包，则可以省略导包。lung包不需要import。
     import 包路径.类名称;

  2. 第二步：创建
     类名称 对象名 = new 类名称();
     System.in代表从键盘进行输入

  3. 第三步：使用
     对象名.成员方法名()  

     获取键盘输入的一个int数字：int num = sc.nextInt();
     获取键盘输入的一个int数字：String str = sc.next();

## 2.3 匿名对象

### 概念

+ 创建对象的标准格式：

  ```java
  类名称 对象名 = new 类名称();
  ```

+ 匿名对象：只有右边的对象，没有左边的名字和赋值运算符：

  ```java
  new 类名称  
  ```

+ 匿名对象只能使用唯一一次，再用时只能再创建新对象。如果有一个对象只需要使用一次，可以使用匿名对象。

### 应用

+ 匿名对象进行传参

  ```java
  public static void methodParam(Scanner sc){
    ...
  }
  ```

+ 匿名对象作为返回值

  ```java
  public static Scanner methodReturn(){
    return new Scanner(Systenm.in);
  }
  ```

  

# 第三章 Random类

## 应用

+ 用途：生成随机数字

+ 使用过程：也是三个步骤

  1. 第一步：导包

     `import Java.util.Random;`

  2. 第二步：创建

     `Random r = new Random()`

  3. 第三步：使用

     获取一个随机的int数字，范围是int所有范围：`nextInt()`

     获取一个随机的int数字，以参数限定范围：`nextInt(a)`范围：[0, a)，即0~(a-1)，参考数组索引。



# 第四章 ArrayList类

数组长度不可以改变，但ArrayList集合可以。

## 泛型

+ 对于ArrayList，有一个<E>代表泛型。

+ 泛型：装在集合中的所有元素，全都是统一的什么类型，如：元素全都是String等。

  注意：泛型只能是引用类型，不能是基本类型。即只能储存地址值。

## 使用

+ 对于ArrayList来说，直接打印得到的不是地址值，而是内容；如果内容是空，打印出的是空的[ ]。

+ 常用方法：

|  方法   |     参数      |           返回值            |       作用       |
| :-----: | :-----------: | :-------------------------: | :--------------: |
|  .add   | E，与泛型一致 |    boolean，是否成功执行    |     添加内容     |
|  .get   | int，索引编号 | E，索引对应内容，与泛型一致 |     读取内容     |
| .remove | int，索引编号 | E，索引对应内容，与泛型一致 |  读取并删除内容  |
|  .size  |      无       |   int，集合包含的元素个数   | 获取集合尺寸长度 |

+ 对于ArrayList来说，add一定成功，返回值可用可不用；

+ 可用list.size遍历集合：

  ```java
  for (int i = 0; i < list.size(); I++){ // 也可直接用list.fori。注意不是list.length
    System.out.println(list.get(i));
  }
  ```

+ ArrayLIst只能储存地址值，如果需要储存基本类型数据，需要使用其包装类：

  | 基本类型 |    包装类     |
  | :------: | :-----------: |
  |   byte   |     Byte      |
  |  short   |     Short     |
  | **int**  |  **Integer**  |
  |   long   |     Long      |
  |  double  |    Double     |
  | **char** | **Character** |
  | boolean  |    Boolean    |

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(100);
```



+ 从JDK 1.5+开始，支持自动装箱、自动拆箱：  
  + 自动装箱：基本类型-->引用类型
  + 自动拆箱：引用类型-->基本类型



# 第五章 String类

API中说，`String`类代表字符串。 Java程序中的所有字符串文字（例如`"abc"` ）都被实现为此类的实例。

也就是说，程序当中所有双引号字符都是`String`类的对象。（即使没有new也是）



## 5.1 特点

1. 字符串是**常量**，内容永不可变。【重点】
2. 因为字符串不可改变，所以字符串可以共享使用。
3. 字符串效果上相当于char[ ]字符数组，但是底层原理是byte[ ]字节数组。



## 5.2 创建

常见3种构造方法，1种直接创建：

```java
//第一种构造方法，创建一个空白字符串，不含有任何内容
public String()

//第二种构造方法，根据字符数组的内容创建对应字符串
public String(char[] array)
    
//第三种构造方法
public String(byte[] array)
    
//直接创建
String str = "Hello"
```



## 5.3 常量池

+ 字符串常量池在**堆**中。
+ 程序中直接写上的双引号字符，就在字符串常量池中；`new`的字符串不在常量池中。

+ 对于基本类型，`==`是比较数值；对于引用类型，`==`是比较地址值。



## 5.4 常用方法

+ 比较字符串内容：

  1. ```java
     public boolean equals(Object obj)
     ```

     + 参数可以是任何**对象**，只有参数是字符串且相同，才会返回true；

     + equals具有对称性，即`a.equals(b)`和`b.equals(a)`效果一样；

     + 如果比较双方一个常量一个变量，推荐把常量字符串写在前面，如：

       推荐：`"abc".equals(str1)`

       不推荐：`str1.equals("abc")`

       因为变量为`null`时前者返回`false`，后者报错空指针异常`NullPointerException`

  2. ```java
     public boolean equalsIgnoreCase(String str)
     ```

     + 忽略大小写进行内容比较。

       

+ 获取相关

  ```java
  //获取字符串当中含有的字符个数，拿到字符串长度；
  public int length()
  
  //将当前字符串和参数字符串拼接为新的字符串，return；如果有null，会空指针异常
  public String concat(String str)
  
  //获取指定索引位置的单个字符
  public char charAt(int index)
  
  //查找参数字符串在本字符串中首次出现的索引位置，没有则返回-1值
  public int indexOf(String str)
  ```

  

+ 截取相关

  ```java
  // 截取从参数位置一直到字符串末尾，返回新字符串
  public String substring(int index)
  
  // 截取从begin开始，end结束，中间的字符串，[begin, end)，包含左边，不包含右边
  public String substring(int begin, int end)
      
  // 注意：截取之后原字符串不发生变化。
  ```

  

+ 转换相关

  ```java
  // 将当前字符串拆分成为字符数组，return
  public char[] toCharArray()
  
  // 获得当前字符串底层的字节数据
  public byte[] getBytes()
      
  // 将所有出现的老字符串(oldString)替换为新字符串(newString)，返回新的字符串
  // CharSequence意思是可以接受字符串类型，可以看做String
  public String replace(CharSequnce oldString, CharSequence newString)
  ```



+ 分隔

  ```java
  // 按照参数规则，将字符串切分成为若干部分
  public String[] split(String regex)
  ```

  + split方法参数是正则表达式(regex)，"."等符号需要`\\`进行转义



# 第六章 static静态关键字

## 6.1 static field

+ 使用了static关键字的内容不再属于对象自己，而是属于类，所以凡是属于本类的对象都共享同一份。
+ 给其中一个赋值，其他所有对象都会改变



## 6.2 static method

+ 使用方法
  1. 一旦使用static修饰成员方法，就成为了静态方法。
  2. 静态方法不属于对象，而是属于类。
  3. 如果没有static关键字，则必须先创建对象才能使用。
  4. 对于静态方法，可以通过对象名进行调用（不推荐），也可以通过**类名称**进行调用。
  5. 无论是**静态变量**还是**静态方法**，都推荐使用类名称进行调用。
  6. 对于**本类当中的*静态*方法**，可以省略类名称。

+ 注意事项
  1. 静态不能直接访问非静态：如静态方法不能直接访问成员变量，因为在内存中**先**有静态，**后**有非静态内容；
  2. 静态方法中不能用this：this代表当前对象，但静态方法和对象无关。
  
     

## 6.3 静态代码块

+ 格式：

```java
public class 类名称{
    static{
        // 静态代码块内容
    }
}
```

+ 特点：当**第一次**用到本类，静态代码块执行**唯一**的一次。
+ **静态内容总是优先于非静态**，静态代码块比构造方法优先执行。
+ 静态代码块的典型用途：用于一次性地对静态成员变量赋值。



# 第七章 Arrays类

Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见的操作。

常用方法：

+ `public static String toString(Array)`：将参数数组变成字符串，按照默认格式：[元素1, 元素2, 元素3 ...]。w

+ `public static void sort(Array)`：对数组元素进行排序，按照默认升序。

  ```java
  public static void main(String[] args){
      int[] array1 = {2, 1, 3, 5, 12};
      Arrays.sort(array1);
      System.out.println(Arrays.toString(array1)); //[1, 2, 3, 5, 12]
  }
  ```

  + 如果是数值，`sort`默认按照从小到大；
  + 如果输字母，默认按照字母升序；
  + 如果是自定义类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。



# 第八章 Math类

java.lang.Math 类是数学相关的工具类，里面有大量的静态方法，完成与数学运算相关的操作。

常用方法

+ `public static double abs(double num)`：获取绝对值。
+ `public static double ceil(double num)`：向上取整。
+ `public static double floor(double num)`：向下取整。
+ `public static long round(double num)`：四舍五入。
+ `Math.PI`：代表近似圆周率



# 第九章 抽象类

## 9.1 概述

如果父类当中的方法不确定如何进行方法体实现，这就是一个抽象方法。

![抽象方法](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1612869913823-1612869913794.png)

## 9.2 定义与使用

+ 抽象方法：加上`abstract`关键字，去掉大括号，直接分号结束。

  ```java
  public abstract void eat();
  ```

+ 抽象类：抽象方法所在的类必须是抽象类，在class之前写上abstract即可。

+ 使用：

  1. 不能直接创建new抽象类对象；

  2. 必须用一个子类来继承抽象父类；

  3. 子类必须覆盖重写抽象父类当中所有的抽象方法；

     覆盖重写（实现 implements）：去掉抽象方法的`abstract`，然后补上方法体。

## 9.3 注意事项

1. 抽象类**不能创建对象**；
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员用的；
3. 抽象类中，不一定包含抽象方法，但有抽象方法的一定是抽象类；
4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则编译无法通过，除非子类也是抽象类。



# 第十章 接口(interface)

接口是一种公共的规范标准。

只要符合规范标准，就可以大家通用。



## 10.1 基本格式

+ 接口就是多个类的公共规范。

+ 接口是一种引用数据类型，最重要的内容就是其中的**抽象方法**。

+ 一个接口可以继承`extends`多个接口

+ 如何定义一个接口格式：

  ```java
  public interface 接口名称{
      接口内容;
  }
  ```

  备注：关键字class换成interface之后，编译生成的字节码文件仍然是 .java --> .class。

+ 如果是java7，那么接口中可以包含的内容有：

  1. 常量
  2. 抽象方法

+ 如果是java8，还可以**额外包含**有：

  3. 默认方法
  4. 静态方法

+ 如果是java9，还可以**额外包含**有：

  5. 私有方法



## 10.2 各种方法的定义与使用

### ①抽象方法(abstract)

在任何的java版本中，接口都能定义抽象方法。

格式：

```java
public abstract void 方法名();
```

注意事项：

1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：`public`、`abstract`；
2. 这两个关键字修饰符，可以选择性地**省略**；
3. 方法的三要素（方法名、参数、返回值）可以随意定义。

使用

1. 接口不能直接使用，必须有一个“实现类”来“实现（implements)”该接口。

   格式：

   ```java
   public class 实现类名称 implements 接口名称{
       
   }
   ```

2. 接口的实现类必须覆盖重写接口中所有的抽象方法。

   实现：去掉`abstract`关键字，加上方法体大括号。

3. 创建实现类的对象，进行使用。不能直接new接口对象！

注意事项：

如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类必须是**抽象类**。



### ②默认方法(default)

从java8开始，接口里允许定义默认方法。

格式：

```java
public default 返回值类型 方法名称(参数列表){
    方法体;
}
```

备注：

接口当中的默认方法可以解决接口升级的问题，不用再去每个子类里实现。

使用

1. 默认方法会被实现类**继承**；

2. 接口的默认方法，可以通过接口实现类对象**直接调用**；

3. 接口的默认方法，也可以被接口实现类进行**覆盖重写**。

   

### ③静态方法(static)

从Java8开始，接口里允许定义静态方法。

格式：

```java
public static 返回值类型 方法名称(参数列表){
    方法体;
}
```

使用

1. 不能通过接口实现类的对象来调用接口中的静态方法（一个实现类可以实现多个接口）；
2. 正确用法：通过接口名称直接调用其中的静态方法。



### ④私有方法(private)

从Java9开始，接口里允许定义私有方法：

1. 普通私有方法：解决多个默认方法之间重复代码问题；

格式：

```java
private 返回值类型 方法名称(参数列表){
    方法体
}
```



1. 静态私有方法：解决多个静态方法之间重复代码问题；

```java
private static 返回值类型 方法名称(参数列表){
    方法体
}
```



## 10.3 常量的定义与使用

接口当中也可以定义“成员变量”，但是必须使用 `public static final`三个关键字进行修饰。

从效果上看，这其实就是接口的【常量】。

格式：

```java
public static final 数据类型 常量名称 = 数据值;
```

注意：

1. 使用`final`关键字，说明不可改变。

2. 接口当中常量可以省略`public static final`三个关键字，不写也会触发。
3. 接口当中的常量必须进行赋值，不能不赋值。
4. 接口当中的常量，名字要用完全大写，多个单词用 "_" 连接。（推荐命名规则）



## 10.4 注意事项

1. 接口不能有静态代码块或者构造方法；

2. 一个类的直接父类是唯一的，但一个类可以同时实现多个接口，

   格式：

   ```java
   public class 类名 implements 接口1, 接口2, ...{
       
   }
   ```

3. 如果实现类实现的接口中有重复的抽象方法，只需要覆盖重写一次；

4. 如果实现类没有覆盖重写所有抽象方法，实现类必须是抽象类；

5. 如果实现类实现的接口中有重复的默认方法，那么实现类一定要对冲突的默认方法进行**覆盖重写**；

6. 一个类如果直接父类的方法，和接口中的默认方法产生了冲突，优先用父类的方法。



## 10.5 接口间的多继承

1. 类与类之间是但继承的，直接父类只有一个；
2. 类与接口直接是多实现的。一个类可以实现多个接口；
3. 接口与接口之间是**多继承**的。

注意事项：

1. 多个父接口之间的抽象方法可以重复；
2. 多个父接口之间的默认方法不可重复，需要重写，且带着default关键字。



# 第十一章 final关键字

final关键字代表最终、**不可改变**的。

final的4种常见用法：

1. 可以用来修饰一个类
2. 可以用来修饰一个方法
3. 可以用来修饰一个局部变量
4. 可以用来修饰一个成员变量



## 11.1 修饰类

 final关键词用来修饰一个类时：

- 格式：

  ```java
  public final class 类名称{}
  ```

- 含义：当前类不能有任何**子类**

- 注意：一个类如果是final，那么其中所有成员方法都无法覆盖重写，



## 11.2 修饰方法

+ 含义：final修饰方法时，该方法**不能被覆盖重写**。

+ 格式：

```java
public final 返回值类型 方法名称(参数列表){}
```

+ 注意：对于类和方法来说，final关键字和abstract关键字不能同时使用，因为矛盾。



## 11.3 修饰局部变量

+ 含义：final修饰局部变量时，该变量不能进行更改。

+ 格式：可以直接赋值，也可以先创建再赋值；

```java
int final num = xxx;
//或者
int final num;
num = xxx;
```

+ 注意事项：

  对于基本类型来说，不可变说的是变量当中的数据不可变；

  对于引用类型来说，不可变说的是**地址值**不可变。



## 11.4 修饰成员变量

- 含义：final修饰成员变量时，该变量不能进行更改。
- 注意：
  1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值；
  2. 对于使用final的成员变量，要么使用直接赋值，要么通过构造方法赋值；
  3. 必须保证**所有重载方法**都会对成员变量进行赋值；



# 第十二章 权限修饰符

Java中有四种权限修饰符：

|              | public | protected | (default) | private |
| ------------ | :----: | :-------: | :-------: | :-----: |
| 同一个类     |   ✔️    |     ✔️     |     ✔️     |    ✔️    |
| 同一个包     |   ✔️    |     ✔️     |     ✔️     |    ❌    |
| 不同包子类   |   ✔️    |     ✔️     |     ❌     |    ❌    |
| 不同包非子类 |   ✔️    |     ❌     |     ❌     |    ❌    |

注：子包不算同一个包



# 第十三章 内部类

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类（内部类）。

例如：身体和心脏的关系、汽车和发动机的关系。

内部类分为**成员内部类**和**局部内部类**（含匿名内部类）。



## 13.1 成员内部类

+ 成员内部类的定义格式：

```java
修饰符 class 外部类名称{
    修饰符 class 内部类名称{
        ...
    }
}
```

+ 注意：内用外，随意访问；外用内，需要内部类对象。

+ 使用：

  1. 间接方式：在外部类的方法中，使用内部类；main只是调用外部类的方法。

  2. 直接方式：公式：

     ```java
     //正常方式, 不能用于内部类
     类名称 对象名 = new 类名称;
     //正确用法: 对于静态内部类
     外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
     //对于非静态内部类, 先new外部类
     外部类名称 外部类对象名 = new 外部类名称();
     外部类名称.内部类名称 对象名 = 外部类对象名.new 内部类名称()
     ```

+ 同名变量访问：

  ```java
  // 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
  public class Outter{
  
      int num = 10; // 外部类的成员变量
      
      public class inner{
          int num = 20; // 内部类的成员变量
          
          public void methodInner(){
              int num = 30; // 内部方法的局部变量
              System.out.println(num); // 30
              System.out.println(this.num); // 20
              System.out.println(Outer.this.num); // 10
          }
      }
  }
  ```

  

## 13.2 局部内部类（包含匿名内部类）

+ 定义：如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

+ “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 

+ 定义格式：

  ```java
  修饰符 class 外部类名称{
  	修饰符 返回值类型 外部类方法名称(参数列表){
  		class 局部内部类名称{
              ...
          }
      }
  }
  ```

+ 注意：

  局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是**有效final的**（从 Java 8+开始，可以不写final，但只能赋值一次）

  原因：

  1. new出来的对象在堆内存中；
  2. 局部变量时跟着方法走的，在栈内存当中；
  3. 方法运行结束之后立刻出栈，局部变量立刻消失；
  4. 但new出来的对象会在堆当中持续存在，直到垃圾回收消失。

+ 小结一下类的权限修饰符

  1. 外部类：public、default
  2. 成员内部类：public、protected、default、private
  3. 局部内部类：什么都不能写

### **匿名内部类**

开发中

如果接口的实现类（或者父类的子类）只需要使用唯一的一次，那么这种情况下可以省略掉该类的定义，改为使用**匿名内部类**。

+ 定义格式：

  ```java
  接口名称 对象名 = new 接口名称(){
      覆盖重写所有抽象方法；
  }
  ```

+ 注意事项

  1. 匿名内部类在**创建对象**的时候，只能使用唯一一次；

  2. 匿名对象在**调用方法**的时候只能调用一次；

  3. 匿名内部类是省略了实现类或子类，但匿名对象是省略了对象名称。

     匿名内部类和匿名对象不是一回事！

+ 任何对象都可以作为类的成员变量

  + 一个类可以作为类的成员变量，参数为类的名称；
  + 一个接口可以作为类的成员变量，参数为接口的实现类。



# 第十四章 Object类

`java.lang.Object`类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是 Object。

如果一个类没有指出extends父类，那默认继承Object类。

## `.toString`方法

返回该对象的字符串表示。

+ 可以重写以替换掉toString的作用。

+ 直接打印一个对象，会默认调用toString方法。

+ 看一个类是否重写了toString方法，直接打印这个类对应对象的名字即可：

  如果没有重写，打印出的就是对象的地址值；

  如果重写了，那么会按照重写的方法打印。



## `equals`方法

指示其他对象是否与此对象相等。

+ 源码：

  ```java
  public boolean equals(object obj){
      return (this == obj);
  }
  ```

  + 基本数据类型：比较的是值
  + 引用数据类型：比较的是地址值

+ 比较两个地址值没有意义，需要重写

+ 问题：

  隐含着一个多态，无法使用子类特有的内容；

  `Object obj = p2 = new Person(); `

  解决：向下转型（强转），然后比较两个对象的属性。



# 第十五章 Objects类

Objects是JDK7添加的工具类，提供了一些静态方法，多是null-sava（空指针安全的）或null-tolerant（容忍空指针的）。

+ Objects类的 equals方法：对两个对象进行比较，防止空指针异常



# 第十六章 日期时间类

## 16.1 Date类

java.util.Date类表示**特定的瞬间**，精确到毫秒。

### **毫秒值**的作用：可以对时间和日期进行计算

+ 2099-01-03到2088-01-01，中间一共有多少天

  可以把日期转换为毫秒进行计算，再把毫秒转换为日期

  把日期转换为毫秒：

  ​	当前的日期：2088-01-01

  ​	时间原点（0毫秒）：1970 年 1 月 1 日 00:00:00（英国格林威治 GMT）

  ​										1970 年 1 月 1 日 08:00:00（中国 CST）

  ​	就是计算当前日期到时间原点之间一共经历了多少毫秒

```java
System.out.println(System.currentTimeMills());#获取当前系统时间到原点经历了多少毫秒
```

### 构造方法

+ 空参构造：date()

  ```java
  Date date = new date();
  System.out.println(date);//不是地址值，是当前时间
  ```

  直接打印，内容为**当前时间**

+ 带参构造：date(long date)

  传递毫秒值，并转换为Date日期（+时间原点 CST）



### 常用方法

+ `long getTime()`：返回时间原点以来，此Date对象表示的毫秒数（相当于System.currentTimeMillis()方法）



## 16.2 DateFormat类

`java.text.DateFormat`对日期进行格式化的**抽象类**。

一般使用其子类`SimpleDateFormat`

+ 作用：格式化（日期 -> 文本）、解析（文本 -> 日期）



### DateFormat成员方法：

+ String format(Date date)

  按照指定的模式，把Date日期，格式化为符合模式的字符串。

+ Date parse(String source)

  把符合模式的字符串，解析为Date日期

### SimpleDateFormat

+ 构造方法

  + `SimpleDateFormat(String pattern)`

    用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat

  + 参数

    String pattern：传递指定的模式

  + 模式：区分大小写

    | 符号 | 含义 |
    | ---- | ---- |
    | y    | 年   |
    | M    | 月   |
    | d    | 日   |
    | H    | 时   |
    | m    | 分   |
    | s    | 秒   |

  + 注意：模式中的字母不能改变，连接模式的符号可以改变

    yyyy年MM月dd日 HH时mm分ss秒

    yyyy-MM-dd HH:mm:ss

    

## 16.3 Calendar类

java.util.Calendar日历类对Date类进行了很多替换，是一个**抽象类**。它提供了很多操作日历字段的方法。

+ 日历字段：YEAR、MONTH、DAY_OF_MONTH、HOUR等

+ 无法直接创建对象，

  常用创建方法：`Calendar rightNow = Calendar.getInstance()`

  `.getInstance()`返回了Calender类的子类对象：使用默认时区和语言环境获得一个日历。

  

### 常用方法

+ `public int get(int field)`：返回给定日历字段的值

  + int field：日历类的字段，可以使用Calendar类的静态成员变量获取。

+ `public void set(int field, int value)`：将给定的日历字段设置为给定值

  + 同时设置，有重载`(int YEAR, int MONTH, int DAY_OF_MONTH)`

+ `public abstract void add(int field, int amount)`：根据日历规则，为给定的日历字段添加或减去指定的时间量

  + int amount：增加减少的值

    正数：增加

    负数：减少

+ `public Date getTime()`：返回一个表示此Calendar时间值的Date对象



| 字段         | final int field | 含义         |
| ------------ | --------------- | ------------ |
| YEAR         | 1               | 年           |
| MONTH        | 2               | 月           |
| DATE         | 5               | 月中的某一天 |
| DAY_OF_MONTH | 5               | 月中的某一天 |
| HOUR         | 10              | 时           |
| MINUTE       | 12              | 分           |
| SECOND       | 13              | 秒           |

```java
psvm{
//get()
    Calendar c = Calendar.getInstance();
    int year = c.get(Calendar.YEAR); //year = 2021
    int month = c.get(Calendar.MONTH);//month = 2(西方月份0-11，东方月份1-12，此处为西方月份)
    
//add
    c.add(Calendar.YEAR, 2);//增加两年
    c.add(Canlendar.MONTH, -3);//减少两个月
    
//getTime()
    sout(c.getTime());//Thu Mar 11 17:33:14 CST 2021
}
```



# 第十七章 System类

java.lang.System类提供大量的静态方法。

常用方法：

+ `public static long currentTimeMillis()`：返回以**毫秒**为单位的当前时间
+ `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`将数组中指定数据拷贝到另一个数组中



## 17.1 currentTimeMillis

+ 可用于测试程序运行时长等：

```java
psvm{
    long s = System.currentTimeMillis();
    ...
    long e = System.currentTimeMillis();
    System.out.println("耗时" + (e-s) + "毫秒");
}
```



## 17.2 arraycopy

+ 作用：从源数组中复制n个元素，并**取代**目标数组中的n个元素（不会变长）
+ 参数：
  + src - 源数组（source）
  + srcPos - 源数组中的起始位置
  + dest - 目标数组（destination）
  + destPos - 目标数组中的起始位置
  + length - 要复制的元素数量

```java
psvm{
    int[] src = {1, 2, 3, 4, 5};
    int[] dest = {6, 7, 8, 9, 10};
    System.static.arraycopy(src, 0, dest, 0, 3);
    sout(Arrays.toString(dest)); //{1, 2, 3, 9, 10}
}
```



# 第十八章 StringBuilder

字符串是常量，不能更改，字符串的底层是一个被`final`修饰的数组；字符串缓冲区支持可变字符串。

```java
	String str = "abc"
// 等效于
    char data[] = {'a', 'b', 'c'};
	String str = new String(data);
```

进行字符串的相加，内存就会有**多个字符串**，占用空间多，效率低。



## 18.1 StringBuilder类

StringBuilder是字符串缓冲区，可以看成一个长度可变的字符串。

底层也是一个数组，但没有被final，初始容量为16，满了则增加16。

### 构造方法

+ `StringBuilder()`：构造一个不带任何字符的字符串生成器，初始容量为16；
+ `StringBuilder(String str)`：构造一个字符串生成器，初始化为指定内容。



### 常用方法

常用方法有两个：

+ `public StringBuilder append()`：添加任意类型的字符串形式，并**返回当前对象自身**；

+ `public String toString()`：将当前StringBuilder对象转换为String对象。

  



# 第十九章 包装类

基本数据类型使用起来较方便，但没有对应的方法来操作数据。

可以使用包装类来装基本类型的数据，在类中定义方法，来操作基本数据。

| 基本类型 |    包装类     |
| :------: | :-----------: |
|   byte   |     Byte      |
|  short   |     Short     |
| **int**  |  **Integer**  |
|   long   |     Long      |
|  double  |    Double     |
| **char** | **Character** |
| boolean  |    Boolean    |



## 19.1 装箱与拆箱

+ 装箱：把基本类型的数据变成包装类

  + 构造方法(方法上有横线, 说明过时了)：

    `Integer(int value)`: 构造一个新的Integer对象,表示指定的int值;

    `Integer(String s)`: 表示String参数所指示的值;传递的字符串必须是基本类型的字符串(如"100"), 否则抛出异常`NumberFormatException`: 数字格式化异常

  + 静态方法:

    `static Integer valueOf(int i)`: 返回一个表示指定int值得Integer实例;

    `static Integer valueOf(String s)`

+ 拆箱: 把包装类变为基本类型的数据

  + 成员方法: 

    `int intValue()`以int类型返回Integer的值

```java
Integer in1 = Integer.valueOf(1);
int i = in1.intValue();
```



## 19.2 自动拆箱与自动装箱

JDK1.5之后出现的新特性. 

+ 自动装箱: 直接把int类型的整数赋给包装类

  `Integer in = 1;`

+ 自动拆箱: 

  `in = in + 2;`



## 19.3 基本类型与字符串类型的相互转换

+ 基本 -> 字符串

  1. 基本类型的值 + ""
  2. 包装类的静态方法`toString(参数)`, 不是Object类的`toString`方法, 重载
  3. String类的静态方法`valueOf(参数)`

+ 字符串 -> 基本

  使用包装类的静态方法`parseXXX("字符串")`

  ​	Integer类: `static int parseInt(String s)`等

```java
//基本 -> 字符串
String s1 = Integer.toString(100);
String s2 = String.valueOf(100);
    
//字符串 -> 基本
int i = Integer.parseInt(s1);
```



# 第二十章 枚举类

Java5.0新增内容

+ 如果类的对象只有有限个, 且确定, 则称此类为枚举类, 如: 星期, 季节, 性别, 支付方式, 就职状态
+ 如果需要定义一组**常量**, 强烈建议使用**枚举类**
+ 如果枚举类只有**一个对象**, 则可以作为**单例模式**的实现方式

## 20.1 自定义枚举类

+ 两种方式

  1. JDK5.0之前自定义枚举类

  2. 使用enum关键字

     ```java
     //方法1
     class Season{
         // 1. 声明Season对象的属性: private final修饰
         private final String seasonName;
         private final String seasonDesc;
         
         // 2. 私有化类的构造器, 并给对象属性赋值
         private Season(String seasonName, String seasonDesc){
             this.seasonName = seasonName;
             this.seasonDesc = seasonDesc;
         }
         
         // 3. 提供当前枚举类的多个对象, public static final
         public static final Season Spring = new Season("春天", "春暖花开");
         public static final Season Summer = new Season("夏天", "夏日炎炎");
         public static final Season Autumn = new Season("秋天", "秋高气爽");
         public static final Season Winter = new Season("冬天", "冰天雪地");
         
         // 4. 其他诉求: 获取枚举类属性
         getter();
         toString();
     }
     
     // 调用
     psvm{
         Season spring = Season.Spring;
     }
     ```

     

## 20.2 enum关键字

JDK5.0时使用enum关键字(常用)

```java
// class改为enum
enum Season{
    // 1. 多个对象之间用逗号隔开, 需要构造器
    Spring = new Season("春天", "春暖花开"),
    Summer = new Season("夏天", "夏日炎炎"),
    Autumn = new Season("秋天", "秋高气爽"),
    Winter = new Season("冬天", "冰天雪地");
    
    /*
    可以简写为: 
    Spring("春天", "春暖花开")...
    */
    /*
    如果没有属性, 不需要构造器: 
    Spring,Summer,Autumn,Winter;
    */
    
    // 2. 声明对象属性
    // 3. 其他诉求
    	// toString默认重写为对象名
    	// Season.class.getSuperClass() // java.util.Enum
}
```



## 20.3 Enum类主要方法

+ `values()`返回一个数组, 存储其中所有对象

  ```java
  Season[] values = Season.values(); // [Spring,Summer,Autumn,Winter]
  ```

+ `valueOf()` 根据名字返回对象, 没找到就抛异常

  ```java
  Season winter = Season.valueOf("Winter");
  ```

+ `toString()` 默认打印对象名称(枚举的其中一项内容)

## 20.4 实现接口的枚举类

使用enum关键字定义的枚举类实现接口

+ 几种情况

  1. 和用class定义的类一样, `implements`接口, 然后重写抽象方法, 用任何枚举类去调, 内容都一样

  2. 每一个对象都去重写方法

     ```java
     ...
         Spring("春天", "春暖花开"){
             @Override
             ...
     	},
     	Summer...
     ```

     

# --------------------



# **第四部分 数据结构**



# 第一章 Collection集合

## 1.1 集合概述

+ 集合: java中提供的一种容器,用来储存多个数据;

+ 数组长度**固定**, 集合长度**可变**; 

+ 数组存储**同一类型**的元素, 可以是**基本类型**;  集合存储的都是**对象**, 且对象类型可以不一致. 

  只能`ArrayList<Integer>`



## 1.2 集合框架

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1615988093830-1615988093803.png)

集合框架的学习方式: 

+ 学习顶层接口/抽象类的共性方法, 所有子类都可以用
+ 使用底层: 顶层不是接口就是抽象类, 无法创建对象, 使用底层的子类创建对象使用. 



## 1.3 Collection常用功能

+ `public boolean add(E e)`: 向集合中添加对象
+ `public void clear()`: 清空集合中的元素
+ `public boolean remove(E e)`: 把给定的元素从集合中删除
+ `public boolean contains(E e)`: 判断集合中是否包含给定对象
+ `public boolean isEmpty`: 判断当前集合是否为空
+ `public int size()`: 返回集合中元素个数
+ `public Object[] toArray`: 把集合中元素存储到数组中



# 第二章 Iterator迭代器

## 2.1 Iterator接口

+ **迭代**: 即 Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素, 如果有, 就把这个元素取出来, 继续判断, 如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

+ 两个常用方法:

  + `boolean hasNext()`: 判断集合有没有下一个元素, 有就返回true
  + `E next()`: 返回迭代的下一个元素

+ Iterator是一个接口, 无法直接使用, 获取实现类的方法比较特殊

  Collection接口中有一个方法叫做`Iterator<e> iterator()`: 返回在此Collection的元素上进行迭代的迭代器

+ **迭代器的使用步骤**: 

  1. 使用集合中的方法`iterator()`获取迭代器的实现类对象, 使用Iterator接口接受(多态)
  2. 使用Iterator接口中的方法hasNext判断还有没有下一个元素
  3. 使用Next取出集合中的下一个元素

  ```java
  Collection<String> coll = new ArrayList<>();
  coll.add("a");
  coll.add("b");
  coll.add("c");
  coll.add("d");
  coll.add("e");
  Iterator<String> it = coll.iterator();
  boolean b = it.hasNext()
  String s = it.next;
  //循环写法
  for(Iterator<String> it2 = coll.iterator(); it2.hasNext){}
  ```

  

## 2.2 增强for循环

内部原理: 迭代器

JDK1.5之后出现的新特性

`Collection extends Iterable<E>`: 所有的单列集合都可以使用增强for

`public interface Itrable<T>`实现这个接口的对象, 允许成为`foreach`语句的目标

格式:

```java
for(元素的数据类型 变量 : Collection集合or数组){
    代码;
}
```



# 第三章 泛型Generic

是一种未知的数据类型, 当不知道什么数据类型的时候可以使用泛型.

泛型也可以看成一个变量, 用来接收数据类型.

+ E e: Element 元素
+ T t: Type 类型

创建集合对象, 不使用泛型:

```java
ArrayList list = new ArrayList;
```

+ 好处: 不使用泛型, 默认的类型就是Object, 可以存储任意类型的数据, 可以不相同;

+ 坏处: 不安全, 会引发异常
  + 用Object obj取出元素,使用的是多态, 不能使用元素特有的方法(如length() )



使用泛型: 

+ 好处:
  1. 避免类型转换, 存储什么类型就取出什么类型
  2. 把运行期异常, 提升到了编译期
+ 弊端: 泛型是什么类型, 就只能存储什么类型的数据.

定义含有泛型的类: 在类名称后面加上<E>;

 

## 3.1 含有泛型的方法

+ 如果直接用类的泛型, 不要在方法中加泛型标记!!!!!!!!

+ 定义含有泛型的方法: 泛型定义在方法的修饰符和返回值类型之间

+ 格式: 

  ` 修饰符 <泛型,写什么都行> 返回值类型 方法名(参数列表(使用泛型) )`

  含有泛型的方法在调用方法的时候确定数据类型. 

```java
public <M> void method01(M m){
    sout(m);
}
```



## 3.2 含有泛型的接口

+ 定义:

`public interface GenericInterface<I>{} `

+ 实现:

  + 第一种实现方式: 定义接口的实现类, 实现接口, 指定接口的泛型

    `public class GenericInterfaceIpml1 implements GenericInterface<String>{}`

  + 第二种实现方式: 接口使用什么泛型, 实现类就使用什么泛型, 相当于定义了一个含有泛型的类



## 3.3 泛型的通配符

+ 泛型通配符: ?

  代表任意的数据类型

+ 使用方式:

  不能创建对象使用

  只能作为方法的参数使用

+ 高级使用----受限泛型

  + 上限限定格式: `类型名称<? extends E> 对象名称`代表使用的泛型只能是E类型的子类或本身
  + 下限限定格式:`类型名称<? super E> 对象名称`代表使用的泛型只能是E类型的父类或本身

# 第四章 数据结构

## 4.1 栈

特点: 先进后出, 入口和出口在集合两侧

+ 入栈/压栈: 存储元素到集合
+ 出栈/弹栈: 取出集合中元素

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1618151845480-1618151845447.png)

## 4.2 队列

特点: 先进先出, 入口和出口在两侧

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1618152241213-1618152241192.png)

## 4.3 数组

+ 特点: 
  + 查询快: 数组的地址连续, 通过首地址找到数组, 通过索引快速查找数组; 
  + 增删慢: 数组的长短固定,增删元素需要创建一个新数组. 



## 4.4 链表

+ 特点:
  + 查询慢: 地址不连续, 从头查询
  + 增删快: 增删元素对整体结构没有影响
+ 分类:
  + 单向链表: 不能保证元素顺序, 存储和取出顺序可能不同
  + 双向链表: 有一条链子专门记录元素顺序, 是**有序集合**



## 4.5 红黑树

+ 二叉树: 分支不超过两个
+ 排序树/查找树: 在二叉树的基础上, 元素有大小顺序: 左子树小, 右子树大
+ 平衡树: 任何节点的子树高度差的绝对值不超过1
+ 红黑树
  + 特点: 趋近于平衡树, **查询速度快**, 查询叶节点最大次数和最小次数不超过2倍
  + 约束条件: 
    + 节点可以是红色或黑色
    + 根节点为黑色
    + 叶节点(空节点)为黑色
    + 每个红色节点的子节点都是黑色
    + 任何一个节点到其每一个叶节点的所有路径上黑节点数量相同



# 第五章 List接口

java.util.List extends Collection

+ 三大特点: 

  1. 是一个有序集合
  2. 有索引
  3. 允许存储重复元素

+ 带索引的方法(特有方法):

  1. public void add
  2. public E get
  3. public E remove
  4. public E set : 替代指定位置的元素, 返回之前的元素

+ 遍历的三种方式:

  1. 普通的for循环

  2. 使用迭代器

     ```java
     Iterator<E> name = list.iterator();
     while(name.hasNext()){
         E e = name.next;
         sout(e);
     }
     ```

     

  3. 使用foreach



# 第六章 List的实现类

## 6.1 ArrayList集合

底层为数组实现, **此实现不是同步的(多线程, 速度快)**. 

如果查询较多, 可用ArrayList. 



## 6.2 LinkedList集合

底层为链表实现, 此实现不是同步的. 

+ 特殊方法: 
  + addFirst/Last
  + removeFirst/Last
  + getFirst/Last
  + pop: 等效于removeFirst
  + push: 等效于addFirst
+ 特点: 
  + 底层为链表结构, 查询慢, 增删快
  + 包含了大量操作收尾元素的方法
  + 注意: 使用LinkedList特有方法, 不能使用**多态**

## 6.3 vector集合(过时)

1.0版本所用单列集合为vector

底层实现为数组, 是同步的(单线程, 慢), 被ArrayList取代



# 第七章 set接口

+ 特点:
  1. 不允许存储重复元素
  2. 没有索引, 不能用for循环遍历

## 7.1 HashSet集合

由HashMap支持, 不保证迭代顺序恒久不变, 允许使用null元素

+ 特点: 
  1. 不允许存储重复元素
  2. 没有索引, 不能用普通for循环遍历
  3. 是一个无序集合, 存取顺序可能不一致
  4. 底层是Hash表结构(查询速度非常快)



## 7.2 HashMap哈希表

+ 哈希值: 十进制整数 int,由系统随机给出, 是**地址值**, 是一个逻辑地址, 不是实际存储的物理地址

+ Object方法: hashCode 返回对象的哈希值

+ String类重写了hashCode方法

+ JDK1.8 之前, 哈希表 = 数组 + 链表

  JDK1.8 之后, 哈希表 = 数组 + 红黑树(提高查询速度)

+ 初始容量16

+ 数组结构:把元素进行分组, 相同哈希值为一组;

  链表/红黑树结构: 把相同哈希值元素连接到一起.

+ 存储数据到集合中:

  + 先计算元素哈希值
  + 哈希冲突: **两个元素不同, 哈希值相同**. 如果存入的哈希值已有, 调用equals方法, 比较元素是否相同, 相同则不会存储后一个; 不同则发生哈希冲突, 挂在同一个位置. 

+ 不允许存储重复元素的原理: 
  + 如果存入的哈希值已有, 调用equals方法, 比较元素是否相同, 相同则不会存储后一个; 不同则发生哈希冲突, 挂在同一个位置. 
  + 前提: 存储的元素必须重写hashCode方法和equals方法
  
+ `getOrDefault(Object K, V defaltValue)`返回K对应的值, 如果没有查询到K, 则返回输入参数中的V

## 7.3 HashSet存储自定义元素

HashSet存储自定义类型元素时, 要保证元素唯一, 需要重写hashCode和equals方法. 



## 7.4 LinkedHashSet

java.util.LinkedHashSet集合 extends HashSet集合

HashSet的子类, 有序, 具有可预知的迭代顺序

+ 特点: 
  + 底层是一个哈希表(数组+链表/红黑树) + 链表(记录元素的存储顺序)
  + 有序, 不允许重复



## 7.5 可变参数

在JDK1.5之后,如果定义一个方法需要接受**多个参数**, 并且多个参数**类型一致**, 可以简化为: 

```java
修饰符 返回值类型 方法名(参数类型... 形参名){ }
// 完全等价于
修饰符 返回值类型 方法名(参数类型[] 形参名){ }
```

+ 原理: 
  + 底层是一个数组, 根据参数个数不同, 会创建不同长度的数组, 来存储这些参数
  + 传递参数的个数可以是 0, 1, 2, ...多个

```java
// 计算多个int类型的和
public static int add(int... arr){
// 传入的arr是一个数组
    int sum = 0;
    for(int i : arr){
        sum += i;
    }
    return sum;
}
```

+ 注意事项: 
  + 一个方法的参数列表只能有一个可变参数; 
  + 如果方法的参数有多个, 那么可变参数必须写在参数列表的末尾;
+ 可变参数的特殊写法(终极写法): `method(Object... obj)`



# 第八章 Collections

+ java.util.Collections是工具类, 用来对集合进行操作
+ 常用方法:
  + `public static <T> boolean addAll(Collection<T> c, T... elements)`: 往c集合中添加一些元素, 返回c
  + `public static void shuffle(List<?> list)`:打乱集合顺序
  + `public static <T> void sort(List<T> list)`: 将集合中元素按照默认规则排序
  + `public static <T> void sort(List<T> list, Comparator<? super T>)`: 将集合中元素按照指定规则排序

+ sort: 

  + 默认规则一般是升序排序: 123/abc

  + 对于自定义列表, 需要实现`Comparable`接口, 重写接口中的`compareTo`方法, 定义排序规则

    ```java
    public class Person implements Comparable<Person>{
        @Override
        public int compareTo(Person o){
            /* 
            返回0, 认为元素相同
            返回负值, this在前: this - o 升序
            返回正值, this在后: o - this 降序
            */
            return this.getAge() - o.getAge();//年龄升序
        }
    }
    ```

+ Comparable和Comparator的区别

  + Comparable: 自己(this)和别人(参数)比较, 自己需要实现Comparable接口, 重写compareTo方法
  + Comparator: 相当于用第三方来比较两个参数

  ```java
  Collections.sort(list, new Comparator<Integer>(){
      @Override // 重写比较规则
      public int compare(Integer o1, Integer o2){
          return o1 - o2; //升序
      }
  }){ // 匿名内部类
      
  }
  ```

  

# 第九章 Map集合

java.util.Map接口<K, V>, 是一个**双列集合**, Collection是**单列集合**. 

+ Map每次存储一对元素, K代表键, V代表值. 
+ key是唯一的, value可以重复
+ Key和Value的数据类型可以相同, 也可以不同
+ key和value一一对应



## 9.1 Map常用实现类

+ java.util.HashMap

  + 特点:

    + 底层是哈希表: 查询速度快

      JDK1.8之前: 数组+单向链表

      JDK1.8之后: 数组+单向链表/红黑树(链表长度超过8变成红黑树, 提高查询速度)

    + HashMap是无序集合, 存取顺序可能不一致

+ java.util.LinkedHashMap<K, V> extends HashMap

  + 特点:
    + 底层是哈希表+链表
    + 是一个有序集合, 存取顺序一致



## 9.2 Map常用方法

+ `public V put(K key, V v)`: 添加指定键值对. 如果key存在, 替换value, 返回原有value; 如果key不存在, 返回null. 
  + 注意: null赋值给int会**空指针异常**, 应用Integer. 
+ `get(Object key)`输入key, 返回value, 没有则返回null
+ `remove(Object key)`: 删除key键值对. key存在, 返回value; key不存在, 返回null
+ `containsKey(Object key)`: 返回是否存在key

## 9.3 遍历Map集合: 

+ 通过键找值方式

  1. 使用`keySet()`把Map集合中所有key取出来, 存储到Set集合中; 

  2. 使用迭代器遍历Set集合; 

  3. 通过`getKey()`获取value.

+ Map.Entry<K, V>: 在Map集合中有一个内部接口Entry, 

  + 作用: Map集合创建时, 会在Map集合中创建一个Entry对象, 用来记录键和值(键值对对象, 键与值的映射关系)

  1. `Set<Map.Entry<K, V>> entrySet()`: 把Map集合的多个Entry对象取出来, 存储到一个Set集合中
  2. 遍历Set集合, 获取每一个Entry对象
  3. Entry有两个方法: `getKey`/`getValue`



## 9.4 HashMap存储自定义类型键值

+ Map集合要保证key是唯一的: 
  + 作为key的元素必须重写hashCode方法和equals方法, 以保证key唯一



## 9.5 LinkedHashMap集合

+ 特点:
  + key不允许重复
  + 存取顺序一致(替换value值, key序号不变)



## 9.6 Hashable集合

+ 特点
  + 键和值都不允许为空
  + 最早期的双列集合(1.0, 其他为1.2)
  + 是同步的(单线程, 线程安全, 慢
  + 和vector集合一样, 被更先进的集合(HashMap)取代了
  + 其子类(Properties)依然在用, 唯一和IO流结合的集合



# 第十章 补充知识

## 10.1 JDK9对集合添加的优化

+ JDK9新特性:
  + List/Set/Map接口: 增加了一个静态方法of, 可以给集合一次性添加多个元素
  + static <E> List<E> of(E... elements)
  + 使用前提: 当集合中存储的元素个数已经确定了, 不再改变
+ 注意:
  + of()方法只适用于List/Set/Map接口, 不适用于接口的实现类
  + of()方法的返回值时一个不能改变的集合, 集合不能再使用add/put等方法添加元素
  + Set和Map接口在调用of方法的时候不能有重复的元素



## 10.2 Debug追踪

+ Debug调试程序:
  + 可以让代码逐行执行, 查看代码执行的过程, 调试程序中出现的bug
+ 使用方式:
  + 在行号的右边, 左键单击, 添加断点(每个方法的第一行, 哪里有bug添加到哪里)
  + 右键, 选择Debug执行程序
  + 程序会停留在添加的第一个断点处(不执行这一行)
+ 执行程序:
  + Step Over: 逐行执行程序 F8
  + Step Into: 进入方法中 F7
  + Step Out: 跳出方法 Shift + F8
  + Resume Program: 跳到下一个断点, 没有则结束程序 F9
  + Console: 切换到控制台



# --------------------

# 第五部分 多线程



# 第一章 异常

## 1.1 异常概念

+ 异常指在程序执行过程中出现的非正常情况, 最终导致JVM非正常停止. 
+ 在Java等面向对象过程语言中, 异常本身是一个类, 产生异常就是创建异常对象并抛出了一个异常对象. Java处理异常的方式是中断处理. 
+ 异常并不是语法错误, 语法错误遍历不会通过, 无法运行. 



## 1.2 异常体系

异常的作用是帮助我们找到程序中的问题. 异常的根类是`java.lang.Throwable`, 其下有两个子类. 平常说的异常指`java.lang.Exception`. 

![image-20210610000658574](../../../../Pictures/PicBed/MDImage/image-20210610000658574.png)



## 1.3 异常分类

+ Exception: 
  + 编译期异常/受检异常, 进行编译(写代码)时出现的问题
  + RuntimeException: 运行时异常/非受检异常, 运行过程中出现的问题
  + 把异常处理掉 程序可以继续执行
+ Error: 错误, 必须修改源代码才能继续执行
  + `StackOverflow`栈溢出, 如递归
  + `OutOfMemory`堆溢出 OOM, 如`new int[1024*1024*1024]`

+ try catch:

  ```java
  try{
      可能出现异常的代码;
  }catch(Exception e){
      异常的处理逻辑;
  }
  ```



## 1.4 异常产生过程的解析

分析异常如何产生, 如何处理. 

+ 检测出异常时, JVM会做两件事:

  1. 根基异常产生的原因创建一个异常对象, 这个对象包含了异常产生的**(内容, 原因, 位置)**

  2. 在使用的方法中没有异常的处理逻辑(try... catch), JVM就会把异常抛出给方法的调用者main方法来处理

     main方法也没有处理逻辑, 继续把对象抛出给main方法的调用者JVM

     JVM收到异常对象, 做了两件事情:

     	1. 把异常对象(内容, 原因, 位置)以红色的字体打印在控制台
     	2. 终止当前正在执行的java程序



# 第二章 异常的处理

java异常处理的五个关键字: **try, catch,  finally,  throw, throws**

## 2.1 抛出异常throw

+ 作用:

  在指定的方法中抛出指定的异常, 同时组织后续所有方法的运行

+ 使用格式: 

  throw new xxxException("异常产生的原因")

+ 注意

  1. throw关键字必须写在方法内部

  2. throw关键字后面new的对象必须是Exception或其子类

  3. throw关键字抛出指定异常对象, 我们就必须处理这个异常对象

     throw后边创建的是RuntimeException或其子类对象, 可以不处理, 默认交给JVM来处理

     throw后边创建的是编译异常, 必须处理异常, 要么throws, 要么try... catch

  ```java
  public static void main(String[] args){
      int arr = null;
      int e = get(arr, 0);
  }
  public static int getElement(int[] arr, int index){
      if(arr == null){
          throw new NullPointerException("传递的数组时null"); //这是一个运行期异常, 不用处理, 默认交给JVM处理
      }
      if(index < 0 || index >= arr.length){
          throw new ArrayIndexOutOfBoundsException("传递的索引超出了数组的使用范围");
      }
  }
  ```

  




## 2.2 Objects非空判断

Objects类是null-save或null-tolerant的, 其源码中对对象为null的值进行了抛出异常的处理. 

+ `public static <T> T requireNonNull(T obj)`: 查看指定引用对象是否为null

  ```java
  public static <T> TrequireNonNull(T obj){
      if(obj == null)
          throw new NullPointerException();
      return obj;
  }
  ```



## 2.3 throws抛出异常

异常处理的第一种方式, 交给别人处理

+ 作用:

  + 当方法内部抛出异常对象, 我们必须处理
  + 可以使用throws关键字处理异常对象, 会把异常对象生命抛出给方法的调用者处理(自己不处理), main方法也抛的话, 最终交给JVM处理(不建议)

+ 使用格式: 在方法声明时使用(要导包), 类名处不用写

  ```java
  修饰符 返回值 类型 方法名(参数列表) throws AAAException, BBBException{
      throw new AAAException("");
      throw new BBBException("");
  }
  ```

+ 注意: 

  + throws关键字必须写在方法声明处

  + throws关键字后面声明的异常必须是Exception或者Exception的子类

  + 方法内部如果抛出多个异常对象, throws必须也声明多个异常

    如果抛出的多个异常对象有父子类关系, 直接声明父类异常即可; 

  + 调用了一个声明抛出异常的方法, 我们就必须处理声明的异常

    要么继续使用throws, 教给方法的调用者处理, 最终交给JVM处理

    要么try... catch自己处理异常

  ```java
  public static void main(String[] args) throws FileNotFountException{
      read("c://a.txt")
  }//调用了抛出异常的方法, 必须自己处理
  
  public static void readFile(String fileName)throws FileNotFountException{
      if(!fileName.equals("c://a.txt")){
          throw new FileNotFountException("文件路径不正确");
      }
  }
  //FileNotFountException是编译异常, 抛出了编译异常就必须处理
  ```

  

## 2.4 try... catch捕获异常

throws缺陷: 后续代码不执行, try... catch后续代码会继续执行

+ 格式:

  ```java
  try{
      可能产生异常的代码(包括throw)
  }catch(定义一个异常变量, 用来接收try抛出的异常对象){
      异常的处理逻辑, 产生异常对象之后, 怎么处理异常对象
      一般在工作中, 会把异常信息记录到一个日志中
  }catch(异常类型 变量名){
      处理逻辑
  }
  ```

+ 注意: 

  1. try中可能抛出多个异常, 可以用多个catch来处理

  2. 如果try产生了异常, 就会执行catch中的异常处理逻辑, 执行完毕catch中的处理逻辑, 会继续执行之后的代码

     如果try没有产生异常, 会正常执行try中代码

+ Throwable类中定义了一些查看异常信息的方法:

  + `public String getMessage()`: 获取获取异常的**简短**描述信息, 原因(提示给用户的时候就提示原因, 即引号内的内容)
  + `public String toString()`: 获取**详细**信息
  + `void printStackTrace()`: JVM打印异常默认调用此方法, **最全面**

  ```java
  try{
      可能产生异常的代码
  }catch(定义一个异常变量, 用来接收try抛出的异常对象){
      sout(e.getMessage()) //文件后缀名不对
      sout(e.toString()) //java.io.IOException: 文件的后缀名不对
      sout(e.printStackTrace()) //交给JVM打印(红色)
  }
  ```



## 2.4 Finally代码块

有一些特定代码, 无论是否发生异常, 都需要执行. Finally中的代码无论如何都会执行. 

+ 格式

  ```java
  try{
      可能产生异常的代码
  }catch(异常类型 变量名){
      处理逻辑
  }finally{
      无论是否出现异常都会执行
  }
  ```

+ 注意: 

  1. finally不能单独使用, 必须和try一起使用
  2. finally一般用于资源释放/资源回收, 无论程序是否出现异常, 最后都要资源释放(IO)



## 2.5 异常的注意事项

+ 多个异常如何处理:

  1. 多个异常分别处理

  2. 一次捕获, 多次处理

     一个try, 多个catch, 注意事项: catch的异常对象, 如果有父子类关系, 子类必须写在上面. 

  3. 一次捕获, 一次处理

+ 运行时的异常, 被抛出可以不处理, 即不捕获也不声明抛出. 默认给JVM处理

+ 如果finally中有return语句, 永远返回finally中的结果, 应避免.  

+ 子父类方法**重写**时的异常:

  + 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常, 或者是父类异常的子类, 或者不抛岀异常。
  + 父类方法没有抛岀昇常,子类重写父类该方法时也不可抛出异常。此时子类产生该异常,只能捕获处理,不能声明抛岀
  + 因为如果使用多态调用子类的重写方法, 如果子类异常范围较大, 可能处理不了该异常. 

+ 注意: 
  父类异常时什么样,子类异常就什么样

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1620024103184-1620024103108.png)



### 如何选择try或throws

1. 如果父类被重写方法没有throws, 子类也不能throws, 只能try...catch
   + 例如: `Thread`类的`run`方法
2. 如果数个方法有递进关系, 前面方法异常后, 后续方法没必要执行时, 一般: 先在其它方法A中一起执行, `throws`异常, 然后对整体方法A进行`try...catch`



# 第三章 自定义异常

java提供的异常类, 不够我们使用, 需要自己定义一些异常类

+ 格式: 

  ```java
  public class XXXException extends Exception | RuntimeException{
      添加一个空参数的构造方法;
      添加一个带异常信息的构造方法;
      public XXXException(String msg){
          super(msg);
      }
  }    
  ```

+ 注意: 

  1. 自定义异常类一般都是以Exception结尾, 说明该类是一个异常类
  2. 自定义异常类, 必须继承Exception或者RuntimeException
     + 继承Exception: 自定义的异常类是一个编译期异常, 如果方法内部抛出了编译器异常, 就必须处理, 要么throws, 要么try... catch
     + 继承RuntimeException: 自定义的异常类是一个运行期异常, 无需处理, 交给JVM(中断处理)



# 第四章 多线程 

## 4.1 并发与并行

+ 并发: 指多个事件在**同一个时间段**内发生----交替执行
+ 并行: 指多个事件在**同一时刻**发生----同时执行



## 4.2 进程与线程

+ 进程: 是指一个内存中运行的应用程序,每个进程都有一个**独立的内存空间**,一个应用程序可以同时运行**多个进程**; 进程也是程序的一次执行过程,是系统**运行程序的基本单位**;系统运行一个程序即是一个进程从创建运行到消亡的过程。

+ 线程: 线程是进程中的一个**执行单元**,负责当前进程中程序的执行,一个进程中**至少有一个线程**。一个进程中是可以有多个线程的, 这个应用程序也可以称之为多线程程序. 
  简而言之: 一个程序运行后至少有一个进程,一个进程中可以包含多个线程

+ 线程是进程中的一个执行单元, 负责程序的执行. 

+ 线程调度: 

  + 分时调度

    所有线程轮流使用CPU的使用权, 平均分配每个线程占用cpu的时间

  + 抢占式调度

    让优先级高的先用, 优先级相同则随机选择



## 4.3 创建线程类

+ 主线程: 执行主方法(main)的线程

+ 单线程程序: java程序中只有一个线程

  执行从main方法开始, 从上到下依次执行

+ 创建多线程程序的第一种方式:创建 Thread类的子类
  java.lang.Thread类: 是描述线程的类,我们想要实现多线程程序,就必须继承 Threa类

+ 实现步骤:

  1. 创建一个Thread子类

  2. 在Thread子类中重写run方法, **设置线程任务**

  3. 创建Thread类的子类对象

  4. 调用Thread类的start方法, 开启新线程, **执行run方法**

     `void start()`: 使该线程开始执行, Java虚拟机调用该线程的run方法。
     当果是两个线程并发地运行，当前线程（main线程）和另一个线程（创建的新线程，执行其run方法）。

+ java程序是抢占式调度

```java
public class MyTread extends Tread{
    
    @Override
    public void run(){
        任务主体;
    }
}
------------
public class Demo{
    public static void main(String[] args){
        MyThread mt = new Mythread();
        mt.start();
    }
}

```



# 第五章 线程

## 5.1 多线程原理

start方法会新建一个栈,运行run方法

## 5.2 Tread类

+ 获取线程名称:
  1. 使用Tread类中的方法`getName()`;
  
     `String getName()`: 返回该线程的名称
  
  2. 先获取到当前正执行的线程, 再使用线程中的方法getName()
  
     `static Thread currentThread()`: 返回当前正在执行的线程对象的引用
  
  ```java
  public class MyThread extends Thread{
      @Override
      public void run(){
          // 1 执行线程时自动打印name
          String name = getName(); 
          System.out.println(name); // Thread-0
          
          // 2 获取当前线程, 打印线程(主线程只能这样获取, 没有getName方法)
          Thread t = Thread.currentThread();
          System.out.println(t); // Thread[Thread-0,5,main]
          
          String name = t.getName();
          System.out.println(name); // Thread-0
          
          //链式编程
          sout(Tread.currentThread().getName()); // Thread-0
      }
  }
  ```
  
+ 线程名称: 

  + 主线程: main
  + 新线程: Thread-0, Thread-1...

+ 设置线程名称

  1. 主方法里使用Thread类的方法setName(String name);
  2. 创建一个带参数的构造方法, 参数传递线程名称; 调用父类的带参构造方法, 吧线程名称传递给父类Thread, 让父类给子线程改名

  ```java
  public class MyThread extends Thread{
      public MyThread(){} //空参构造
      public MyThread(String name){
          super(name); //参数传给父类
      }
      
      @Override
      public void run(){
          sout(Tread.currentThread().getName()); // Thread-0
          
  	}
  }
  ```

+ `public static void sleep(long millis)`: 使当前线程以指定的毫秒数暂停, 毫秒数结束后程序继续执行

  ```java
  psvm{
      // 模拟秒表
      for(int i = 1; i <= 60; i++){
          //使用sleep方法, 让程序睡眠一秒钟
          sout(i);
          try{
              Thread.sleep(1000); // sleep方法自带异常, 但不会触发
          }catch(InterruptedException e){
              e.printStackTrace();
          }
      }
  }
  ```

  

## 5.3 Runable接口

创建多线程程序的第二种方式: 实现Runable接口

+ java. Lang Runnable
  	Runnable接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为run的无参数方法。
  java.tang. Thread类的构造方法
  	Thread( RunnabLe target) 分配新的 Thread对象。
  	Thread( Runnable target, String name) 分配新的 Thread对象。
+ 实现步骤:
  1. 创建一个Runable接口的实现类
  2. 在实现类中重写Runable接口的run方法, 设置线程任务
  3. 创建一个Runable接口的实现类对象
  4. 创建Tread类对象, 传递Runable的实现类对象
  5. 调用Tread的start方法



## 5.4 Tread和Runable的区别

+ 实现Runable的好处:
  1. 避免了单继承的局限性: 一个类只能继承一个类, 实现了Runable接口, 还可以继承其他类, 实现其他接口
  2. 增强了程序的扩展性, 降低了程序的耦合性(解耦): 实现Runable接口的方式, 把设置线程任务和开启新线程进行了分离(解耦)



## 5.5 匿名内部类创建线程

+ 匿名: 没有名字

  内部类: 写在其他类内部的类

+ 作用: 简化代码

  把子类继承父类, 重写父类方法, 创建子类对象一步完成

  把实现类实现接口, 重写接口中的方法, 创建实现类对象一步完成

+ 最终产物: **子类/实现类对象**, 而这个类没有名字

+ 格式: 

  ```java
  new 父类/接口(){
      重写父类/接口中方法
  }
  ```

  例:

  ```java
  psvm{
      //实现Tread类
      new Tread(){
          @Override
          public void run(){
              代码体;
          } 
      }.start;
      
      //实现Runable接口
      Runable r = new Runable(){
          @Override
          public void run(){
              
          }
      };
      new Thread(r).start;
      
      //简化接口
      new Thread(new Runable(){
          @Override
          public void run(){
              
          }
      }).start;
  }
  ```





# 第六章 线程安全

## 6.1 线程安全

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1620651683900-1620651683871.png)

+ 扫描共享数据源: 只创建一个实现类
+ 注意: 
  线程安全问题是不能产生的, 我们可以让一个线程在访问共享数据的时候, 无论是否失去了cpu的执行权, 让其他的线程只能等待, 等当前线程卖完票, 其他线程再进行卖票



## 6.2 线程同步

当我们使用多个线程访问同一资源的时候,且多个线程中对资源有写的操作,就容易出现线程安全问题。

要解决上述多线程并发访问一个资源的安全性问题: 也就是解决重复票与不存在票问题, Java中提供了同步机制(**synchronized**)来解决。

> 窗口1线程进入操作的时候,窗口2和窗口3线程只能在外等着,窗口1操作结束,窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候,其他线程不能修改该资源,等待修改完毕同步之后,才能去抢夺CPU资源,完成对应的操作,保证了数据的同步性,解决了线程不安全的现象. 

为了保证每个线程都能正常执行原子操作Java引入了线程同步机制。

+ 有三种方式完成同步操作
  1. 同步代码块
  2. 同步方法
  3. 锁机制



## 6.3 同步代码块

+ **同步代码块**: `synchronized`关键字可以用于方法中某个区块, 表示只对这个区块的资源实行互斥访问, 锁对象叫**同步锁/对象锁/对象监视器**

+ 格式:

  ```java
  synchronized(同步锁对象){
      需要同步操作的代码(访问了共享数据的代码)
  }
  ```

+ 注意:

  1. 通过代码块中的锁对象, 可以使用任意的对象

  2. 但是必须保证多个线程使用的锁对象是同一个(创建在run方法外面)

  3. 锁对象作用:

     把同步代码块锁住, 只让一个线程在同步代码块中执行

  例:

  ```java
  public class RunnableImpl implements Runnable{
      Object obj = new Object(); //在run方法外创建锁对象,可使不同线程调用同一个锁对象
      
      @Override
      public void run(){
          synchronized(obj){ //调用锁对象, 在对象中放入代码
              需要保证线程安全的代码
          }
      }
  }
  ```

+ 原理: 同步中的线程, 没有执行完毕, 不会释放锁对象; 同步外的线程, 没有锁对象, 进不去同步

+ 程序一直获取/释放锁, 效率会降低



## 6.4 同步方法

+ **同步方法**: 

  1. 把访问了共享数据的代码抽取出来, 放在一个方法中
  2. 在方法上添加`synchronized`修饰符
  3. 在run里面调用同步方法
  4. 格式: 

  ```java
  修饰符 synchronized 返回值类型 方法名(参数列表){
      访问了共享数据的代码
  }
  ```

+ 静态同步: 在synchronized前面加上static, 访问的数据也要加static. 
  + 静态同步的锁对象不能是this: this是创建对象之后产生的, 静态方法优先于对象, 所以静态方法的锁对象是**本类的class文件对象**.



## 6.6 lock锁

`java.util.concurrent.locks.lock`**接口**提供比synchronized更广泛的锁定操作. 

+ 常用方法:

  + `lock()`: 获取锁
  + `unlock()`: 释放锁

+ 使用步骤:

  + `java.util.concurrent.locks.lock.ReentrantLock implements Lock`

  1. 在成员位置(Runnable实现类中)创建一个ReentrantLock对象
  2. 在可能会出现安全问题的代码前调用lock()方法, 获取锁
  3. 在代码后调用unlock()方法释放锁
  4. 建议放在unlock中





# 第七章 线程状态

## 7.1 线程状态概述

+ 线程的六种状态

  + New(新创建)
  + Runnable(可运行)
  + Block(阻塞)
  + Waiting(无限等待)
  + Timed waiting(计时等待)
  + Terminated(被终止, 死亡)

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1620745105300-1620745105249.png)



## 7.2 Timed Waiting计时等待

Timed Waiting线程状态图

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1620745520909-1620745520840.png)

## 7.3 Blocked锁阻塞

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1620745635126-1620745635118.png) 

## 7.4 Waiting无限等待

等待唤醒: 线程之间的通信

顾客调用`wait()`等待方法, 老板做好之后调用`notify()`唤醒方法. 

+ 注意:

  顾客和老板的线程必须使用同步代码块包裹, 保证等待和唤醒只有一个在执行

  同步使用的锁对象必须保证唯一

  只有锁对象才能调用wait和notify方法

  例:

  ```java
  psvm{
      Object obj = new Object;
  	new Thread(){
          @Override
          public void run(){
              ...
              try{
                  obj.wait(); //调用锁对象的wait()
              }catch(Exception e){
                  e.printStackTrace();
              }
              ... //唤醒之后的代码
          }
      }.start;
      new Thread(){
          @Override
          public void run(){
              ...
              obj.notify() //唤醒wait的锁对象
          }
      }.start;
  }
  ```

+ 计时等待有两种方式:

  1. 使用`sleep(long)`方法, 传递毫秒值, 毫秒值结束之后线程睡醒, 进入到Runnable/Block状态
  2. 使用`wait(long)`方法, 如果在毫秒值结束后还没唤醒, 就会**自动醒来**, 进入到Runnable/Block状态

+ 两种唤醒方法:
  1. `notify()`唤醒线程, 如果有多个, 随机唤醒一个. 唤醒后的线程不一定立刻运行, 仍要争取锁
  2. `notifyAll()`唤醒监视器上所有线程



## 第八章 等待唤醒机制

## 8.1 线程间通信

+ **概念:** 多个线程处理同一个资源, 但处理的动作()线程任务却不相同(吃包子, 做包子)

+ 通信(互斥)关系: 必须使用同步技术保证只有一个在执行, 锁对象必须保证唯一(可以使用包子作为锁对象)

+ 可以在包子铺类中创建包子类, 然后使用带参构造, 为包子类赋值`public BaoZiPu(BaoZi bz){this.bz = bz}`



# 第九章 线程池

## 9.1 线程池思想概述

线程池使线程可以复用, 执行完一个任务不被销毁, 可以继续执行其他任务



## 9.2 线程池概念

线程池: 容器--集合

JDK1.5之后, JDK内置了线程池



## 9.3 线程池使用

线程池的工厂类: `java.util.concurrent.Executor`, 用来生产线程池

+ `static ExecutorService newFixedThreadPool(int nThread)`: 创建一个固定线程数的线程池

  参数 int nThread : 线程数量

  返回值 ExecutorService接口的实现类, 可以用ExecutorService接口来接收

+ `java.util.concurrent.ExecutorService`: 线程池接口

  用来冲线程池中获取线程, 调用start方法, 执行线程任务

  `submit(Runnable task)`提交一个Runnable任务用于执行

+ 线程池的使用步骤: 

  1. 使用线程池的工厂类Executor里面的静态方法`newFixedThreadPool()`生产一个指定数量的线程池
  2. 创建一个类, 实现Runnable接口, 重写run方法, 设置线程任务
  3. 调用ExecutorService中的方法`submit()`, 传递线程任务(实现类), 开启线程
  4. 调用ExecutorService中的方法`shutdown()`, 销毁线程池(不建议执行)

  ```java
  psvm{
      ExecutorService es = Executor.newFixedThreadPool(2);
      es.submit(new RunnableImpl());
  }
  ```



# 第十章 Lambda表达式

## 10.1 函数式编程思想概述

+ 面向对象思想:

  做一件事情, 找一个能解决这个事情的对象, 调用对象的方法, 完成事情

+ 函数式的编程思想:

  只要能获取到结果, 谁去做, 怎么做都不重要



## 10.2 Lambda标准格式

用于简化**匿名内部类**

改写代码:

```java
psvm{
    new Thread(new Runnable(){
        @Override
        public void Run(){
            ...
        }
    }).start
        
    //Lambda写法
    new Thread(() -> {
        ...
    })
}
```

+ Lambda表达式由三部分组成: 

  1. 一些参数
  2. 一个箭头
  3. 一段代码

+ 标准格式为:

  `(参数类型 参数名称) -> { 重写方法的代码语句 }`

+ 说明:

  + `()`: 接口中抽象方法的参数列表没有参数就空着, 有参数就写出参数, 多个参数使用逗号分隔
  + `->`: 传递, 把参数传递给方法体
  + `{ }`: 重写接口抽象方法的方法体

  

## 10.3 Lambda省略格式

+ Lambda表达式: 可推导, 可省略

+ 凡是根据上下文推导出的内容, 都可以省略书写

+ 可省略的内容:

  1. (参数列表)括号中的**数据类型**可以省略不写

  2. (参数列表)括号中的参数如果只有一个, 那么**类型和括号**都可以省略

  3. (一些代码)如果{}中的代码只有一行(一个分号), 无论代码是否有返回值, 都可以省略**`{}, return, ;`**

     注意: 要省略, 这三个必须一起省略

  ```java
  //省略前
  invokeCalc(120, (int a) -> {return a * a;});
  
  //省略后:
  //1.
  invokeCalc(120, (a) -> {return a * a;});
  //2. 
  invokeCalc(120, a -> {return a * a;});
  //3. 
  invokeCalc(120, (int a) -> a*a);
  //综合
  invokeCalc(120, a -> a*a)
  ```

  



## 10.4 Lambda的使用前提

1. 使用Lambda必须具有接口, 且要求**接口中有且仅有一个抽象方法**. 

2. 使用Lambda必须具有**上下文推断**

   方法的参数或者局部变量类型必须为Lambda对应的接口类型

+ 注: 有且只有一个抽象方法的接口, 称为"**函数式接口**"



# --------------------

# 第六部分 IO

# 第一章 File类

## 1.1 概述

`java.io.File`类是文件和目录路径名的抽象表示, 主要用于文件和目录的创建, 查找和删除等操作

+ 可以使用file类的方法:
  1. 创建一个文件/文件夹
  2. 删除
  3. 获取
  4. 判断是否存在
  5. 对文件夹进行遍历
  6. 获取文件的大小

+ File类是一个与系统无关的类, 任何操作系统都可以使用这个类的方法. 
+ 重点: 记住三个单词
  1. FIle: 文件
  2. Directory: 目录
  3. Path: 路径  

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1620896646146-1620896646120.png)

+ 路径不区分大小写
+ (Windows下)\是转义字符, 要写两个\\\才能代表一个\

## 1.2 构造方法

+ `File(String pathname)`: 将给定路径名转化为抽象路径名来创建一个新的File实例. 

  pathname可以以文件或文件夹结尾; 

  可以是相对路径或绝对路径

  可以是不存在的或存在的

+ `File(String parent, String child)`: 根据 parent 路径名字符串和 child 路径名字符串创建一个新 `File` 实例。
+ `File(File parent, String child)`: 根据 parent 路径名字符串和 child 路径名字符串创建一个新 `File` 实例。



## 1.3 常用方法

### 获取功能的方法

+ `public String getAbsolutePath()`:返回此File的绝对路径名字符串

+ `public String getpath()`:将此File转换为路径名字符串。

+ `public String getName()`:返回由此File表示的文件或目录的名称。

+ `public long length()`:返回由此File表示的文件的大小, 以字节为单位。

  注意:

  1. 文件夹不能查询大小, 返回0
  2. 如果路径不存在, 返回0



### 判断功能的方法

+ `public boolean exists()`:此File表示的文件或目录是否实际存在。
+ `public boolean isDirectory()`:此File表示的是否为目录
+ `public boolean isFile()`:此File表示的是否为文件。
+ 注: 后两者判断不存在的目录, 都返回false



### 创建删除功能的方法

+ `public boolean createNewFile()`:当且仅当具有该名称的文件尚不存在时,创建一个新的空文件。
  1. 不能创建文件夹
  2. 路径必须存在, 否则抛出异常
  3. 已存在该文件, 返回false
  4. 声明了抛出IOException, 调用时必须处理, 要么继续抛出, 要么try... catch. 

+ `public boolean delete()`:删除由此File表示的文件或目录。

  1. 文件夹中有内容, 不会删除, 返回false
  2. 不存在则返回false
  3. 直接在硬盘中删除, 不走回收站, 谨慎使用
  4. 

+ `public boolean mkdir()`:创建由此File表示的目录。

  给出的路径不存在, 或者已有文件夹, 返回false, 不报错

+ `public boolean mkdirs()`:创建由此File表示的目录,包括任何必需但不存在的**父目录**.



## 1.4 目录的遍历

+ FiLe类遍历(文件夹)目录功能
  1. `public String[] list()`:返回一个 String数组,表示该File目录中的所有子文件或目录。
  2. `public File[] listFiles()`:返回一个File数组,表示该File目录中的所有的子文件或目录。
+ 注意: 
  1. list方法或listFiles方法遍历的是构造方法中给出的目录
  2. 如果构造方法中给出的目录**路径不存在**, 抛出**空指针异常**
  3. 如果构造方法中给出的路径**不是一个目录**, 也会抛出**空指针异常**



## 1.5 FileFilter文件过滤器

+ `File[] listFiles(FileFilter filter)`

+ `java.IO.FileFilter`是一个接口, 用于抽象路径名(File对象)的过滤器

  + 作用: 用来过滤文件

  + 抽象方法: 

    `boolean accept(File pathname)`

    参数: File pathname: 使用ListFiles方法遍历目录, 得到的每一个文件对象

+ `File[] listFiles(FilenameFilter filter)`

+ `java.IO.FilenameFilter`是一个接口, 用于过滤文件名

  + 抽象方法:

    `boolean accept(File dir, String name)`

    参数:

    + File dir: 构造方法中传递的被遍历的目录
    + String name: 使用listFiles方法遍历目录, 获取的每一个文件或文件夹的名称

+ 注意: 两个过滤器规则没有实现类, 需要自己写实现类, 重写accept方法

+ 必须明白两件事情:

  1. 过滤器中accept()方法时谁调用的
  2. accept()方法的参数pathname是什么





# 第二章 IO概述

I : input 输入(读取), 硬盘 -> 内存

O : output 输出(写入), 内存 -> 硬盘

流: 数据(字符, 字节) 1个字符 = 2个字节, 1个字节= 8个二进制位

+ IO分为字符流和字节流

+ 四个父类

![image-20210516191701195](../../../../Pictures/PicBed/MDImage/image-20210516191701195.png)



# 第三章 字节流

## 3.1 一切皆为字节

所有文件数据都是字节. 



## 3.2 OutPutStream 字节输出流

`java.io.OutPutStream`: 此抽象类是表示输出字节流的所有类的超类

+ 定义了一些子类共性的成员方法:
  + `public void close()`:关闭此输岀流并释放与此流相关联的任何系统资源
  + `public void flush()`:刷新此输岀流并强制任何缓冲的输出字节被写出。
  + `public void write(byte[] b)`:将b. Length字节从指定的字节数组写入此输出流。
  + `public void write(byte[] b, int off, int len)`:从指定的字节数组写入Len字节,从偏移量off开始输岀到此输岀流
  + `public abstract void write(int b)`:将指定的字节输出流。

### 3.3 FileOutputStream

`java.io.FileOutputStream extends OutPutStream`也叫文件字节输出流

+ 作用: 把内存中数据写入到硬盘文件中

### 构造方法: 

+ `FileOutputStream(String name)`: 创建一个向具有指定名称的文件中写入数据的输出文件流。

+ `FileOutputStream(File file)`: 创建一个向指定File对象表示的文件中写入数据的文件输出流。

  + 参数: 目的地, 文件**路径字符串**或File文件

+ 作用: 

  1. 创建一个FileOutputStream对象
  2. 根基构造方法中传递的文件/路径, 创建一个**空的文件**
  3. 把FIleOutputStream对象指向创建好的文件

+ 写入数据的原理: 

  java程序 -> JVM(虚拟机) -> OS操作系统 -> 把数据写入文件中

### 字节输出流的使用步骤

1. 创建FIleOutputStream对象
2. 调用对象中的`write()`方法, 把数据写入文件
3. 释放资源(流会占用一定内存, 使用后要清空内存, 通提高效率)
4. 构造/write/close方法都会报错, 可以throws IOException

```java
psvm throws IOException{
    FileOutputStream fos = new FileOutputStream("123/a.txt");
    fos.write("cao".getBytes());
    fos.close();
}
```

+ 任意的文本编辑器(记事本 notepad++-)在打开文件的时候都会查询编码表把字节转换为字符表示
  0-127:查询ASCII表
  其他值查询系统默认码表(中文系统GBK)
+ 一次写多个字节: 
  + 如果写的第一个字节是**正数**(0-127), 那么显示的时候会查询ASCII表
  + 如果写的第一个字节是**负数**,那第一个字节会和第二个字节**两个字节组成一个中文显示**,查询系统默认码表(GBK), 如果第三个是正数, 还是查询ASCII码表; 如果是UTF-8, 则三个字节为一个中文

+ `public void write(byte[] b, int off, int len)`:从指定的字节数组写入Len字节,从偏移量off开始输岀到此输岀流

  参数: 

  + int off: 数组的开始索引
  + int len: 写几个字节

+ 写入字符串的方法:

  使用`getBytes()`: "你好".getBytes();

### 追加写/续写:

+ 使用两个参数的构造方法

  `FileOutputStream(File file, boolean append)`

  `FileOutputStream(String name, boolean append)`

  参数:

  + file/name: 写入数据的目的地

  + append: 追加写开关

    ​	true: 不会覆盖源文件, 会在末尾追加写(已存在的也不会覆盖)

    ​	false: 创建新文件, 覆盖源文件, 单参数构造方法等于使用false

### 换行

写换行符号

Windows: \r \n

Linux: /n

Mac: /r



## 3.3 InputStream字节输入流

`java.io.InputString`是所有字节输入流的超类

+ `int read()`从输入流中读取数据的下一个字节。
+ `int read(byte[] b)`从输入流中读取一定数量的字节,并将其存储在缓冲区数组 b 中。
+ `void close()`关闭此输入流并释放与该流关联的所有系统资源。



## 3.4 FileInputStream

### 构造方法

+ `FileInputStream(String name)`: 创建一个向具有指定名称的文件中写入数据的文件输入流。
+ `FileInputStream(File file)`: 创建一个向指定File对象表示的文件中写入数据的文件输入流。
  + 参数: 目的地, 文件**路径字符串**或File文件
+ 构造方法的作用:
  1. 创建一个对象
  2. 指向要读取的文件

### 读取文件

+ 使用步骤
  1. 创建对象
  2. 使用`read()`读取文件
  3. 释放资源

```java
psvm throws IOException{
    FileInputStream fis = new FileInputStream("123/a.txt");
    //read读取文件的一个字节并返回, 读取到末尾(结束标记)返回-1, 再读取还是-1
    //int len = fis.read(); //返回第一个
    //len2 = fis.read(); //返回第二个
    int len = 0;
    while(len = fis.read() != -1){
        sout((char)len);
    }
    fis.close();
}
```

+ 一次读取多个字节的方法:

+ `int read(byte[] b)`

  明确:

  1. 方法参数byte[]的作用

     缓冲作用, 暂存读取的数据, byte[] b有多长, 读取多长(不算结束标记); 读取内容放在b中

     一般定义为1024的整数倍(1kb)

  2. 返回值int是什么

     读取的有效字节个数(没读取返回-1), 读取了多少个就覆盖b中前几个, 后面的保留

+ String类的构造方法
  `String(byte[] bytes)`:把**字节数组**转换为字符串
  `String(byte[] bytes, int offset, int length)`: 把字节数组的一部分转化为字符串

```java
psvm{
    byte[] bytes = new byte[1024];
    int len = 0;
    while(len = fis.read() != -1){
        sout(new String(bytes, 0, len));//只读取有效的
    }
}
```



# 第四章 字符流

字节流读取中文的时候可能不显示完整字符(占用2(GBK)-3(UTF-8)个字节), 可以使用字符流.

字符流以字符为单位, 专门用于处理文本文件. 

## 4.1 字符输入流 Reader

`java.io.Reader`: 字符输入流, 是字符输入流最顶层的父类, 是一个抽象类

+ 共性方法:

  `read()`读取单个字符。
  `int read(char[] cbuf) `将字符读入数组

  `close()`关闭该流并释放与之关联的所有资源。

### FileReader 文件字符输入流

`public class FileReader extends InputStreamReader`用于读取字符文件的便捷类

+ 作用: 把硬盘文件中的数据以字符的方式读取到内存中

+ 构造方法: 

  `FileReader(File file)` 

  `FileReader(String fileName)`
  + 参数: 读取文件的数据源
  + 作用:
    1. 创建一个FileReader对象
    2. 将对象指向数据源

```java
psvm{
    FileReader = new FileReader;
    int len = 0;
    char[] chs = new char[1024];
    while((len = fr.read(chs)) != -1){
        sout(new String(chs, 0, len));
    }
}
```



## 4.2 字符输出流Writer

+ 共性方法:

  `void write(int c)`写入单个字符
  `void Write(char[] cbuf)`写入字符数组。
  `abstract void write(char[] cbuf, int off, int len)`写入字符数组的某一部分,off数组的开始索引,Len写的字符个数。
  `void write(String str)`写入字符串。
  `void write(String str, int off, int len)`写入字符串的某一部分,of序字符串的开始索引,Len写的字符个数。
  `void flush()`刷新该流的缓冲。
  `void close()`关闭此流,但要先刷新它。

### FileWriter

`java.io.FileWriter extends OutputStreamWriter`

作用: 把内存中的字符写入到文件中

+ 构造方法:
  + `FileWriter(String name)`: 创建一个向具有指定名称的文件中写入数据的输出文件流。
  + `FileWriter(File file)`: 创建一个向指定File对象表示的文件中写入数据的文件输出流。
    + 参数: 目的地, 文件**路径字符串**或File文件

1. 创建FIleWriter对象
2. 调用对象中的`write()`方法, 把数据写入**内存缓冲区**中(字符转换为字节)
3. 调用对象中的`flush()`方法, **把内存缓冲区中的数据刷新到文件中**
4. 释放资源(会自动flush, 第三步可以不写)
5. 构造/write/close方法都会报错, 可以throws IOException

```java
psvm{
    FileWriter fw = new FileWriter;
    fw.write(97);
}
```

### 写其他数据

+ `void Write(char[] cbuf)`写入字符数组。

  也要刷新

+ `abstract void write(char[] cbuf, int off, int len)`写入字符数组的某一部分,off数组

  的开始索引,Len写的字符个数.

+ `void write(String str)`写入字符串。
+ `void write(String str, int off, int len)`写入字符串的某一部分,of序字符串的开始索引,Len写的字符个数。



### 续写和换行

+ 使用两个参数的构造方法

  `FileWriter(File file, boolean append)`

  `FileWriter(String name, boolean append)`

  参数:

  + file/name: 写入数据的目的地

  + append: 追加写开关

    ​	true: 不会创建新文件覆盖源文件, 会在末尾追加写(已存在的也不会覆盖)

    ​	false: 创建新文件, 覆盖源文件, 单参数构造方法等于使用false

### 换行

写换行符号`fw.write("\r\n")`

Windows: \r \n

Linux: /n

Mac: /r



# 第五章 IO异常的处理(try-with-resources)

+ JDK7前处理

```java
psvm{
    FileWriter fw = null; //必须有值才能close
    try{
        fw = new FileWriter();
    }catch(IOException e){
        sout(e);
    }finally{
        try{
            if(fw != null){//防止空指针异常
            	fw.close(); //仍然会有异常
            }
        }catch(IOException e){
            sout(e);
        }
    }
}
```

+ JDK7新特性:

  在try后面可以加一个括号定义流对象, 这个流对象的作用域在try中有效, try执行完毕会自动释放, 不用写finally

```java
psvm{
    try(
    	FileWriter fw = new FileWriter("b.txt");
        FileReader = new FileReader("a.txt");
    ){
        int len = 0;
        ...
    }catch(IOException e){
        sout(e);
    }
}
```



+ JDK9新特性

  在try前可以定义流对象, try后面可以直接引入流对象的名称(变量名), 执行后也可以释放

```java
psvm{
    A a = new A();
    B b = new B();
    try(a, b){
        ...
    }catch(Exception e){
        sout(e);
    }
}
```



# 第六章 属性集Properties

`java.util.Properties extends Hashtable<K, V> implements Mao<K, V>`

Properties类表示了一个持久的属性集, 可保存在流中或从流中加载, 是唯一一个和IO流结合的集合

+ 可以使用Properties的方法`store()`将集合中的临时数据, 持久化写入硬盘中存储
+ 可以使用Properties的方法`load()`将硬盘中保存的文件(键值对)读取到集合中使用
+ 属性列表中每一个键及其对应值都是一个字符串, 默认字符串, 不用写泛型

+ `setProperty(String key, String value)`调用 Hashtable 的方法 put。

+ `getProperty(String key)`用指定的键在此属性列表中搜索属性。(通过Key找到Value), 相当于get或getOrDefault

+ `stringPropertyNames()`返回此属性列表中的键集，其中该键及其对应值是字符串，如果在主属性列表中未找到同名的键，则还包括默认属性列表中不同的键。相当于`keySet()`

+ 可以使用 Properties集合中的方法 store,把集合中的临时数据,持久化写入到硬盘中存储
  `void store(OutputStream out, String comments)`
  `void store(Writer writer, String comments)`

  + 参数:

    OutputStream: 不能写中文, 会显示Unicode码 \uxxxxxx

    Writer: 可以写中文

    comments: 注释, 用来解释文件是干什么用的, 不能使用中文, 会乱码, 一般使用空字符串""

  + 使用步骤:
    1. 创建Properties对象, 添加数据
    2. 创建字节输出流/字符输出流对象, 构造方法中绑定要输出的目的地
    3. 使用Properties的store方法, 写入数据(会写入日期, 所有键值对(k = v))
    4. 释放资源

+ 可以使用 Properties集合中的方法 load,把硬盘中的键值对,读取到集合中使用
  `void load(InputStream inStream)`
  `void store(Reader reader)`

  + 参数:

    inStream: 不能读中文, 会显示Unicode码 \uxxxxxx

    reader: 可以读中文

  + 使用步骤:
    1. 创建Properties对象
    2. 使用Properties的load方法, 读取数据
    3. 遍历Properties, 查看是否读取成功
    4. 释放资源
  + 注意: 
    1. 存储键值对文件中, 键与值可以使用"="或空格连接
    2. 存储键值对文件中, 可以在一行开头加上"#"进行注释, 被注释的键值对不会被读取
    3. 存储键值对文件中, 键与值默认都是字符串, 不用加引号



# 第七章 缓冲流Buffered

缓冲流是对基本流的增强, 加入了缓冲区(数组)

## 7.1 概述

缓冲流也叫高效流, 是对四个基本流的增强, 有四个, 分为:

+ **字节缓冲流**: `BufferedInputStream`, `BufferedOutputStream`
+ **字符缓冲流**: `BufferedReader`, `BufferedWriter`

## 7.2 字节缓冲输出流

+ 构造方法
  `Bufferedoutputstream(OutputStream out`)创建一个新的緩冲输出流,以将数据写入指定的底层输岀流。
  `Bufferedoutputstream(OutputStream out, int size)`创建一个新的缓冲输出流,以将具有指定缓冲区大小的数据写入指定的底层输出流
  + 参数:
    OutputStream out:字节输出流, 我们可以传递 Fileoutputstream,缓冲流会给Fileoutputstream增加一个缓冲区,提高 Fileoutputstream的写入效率
    int size:指定缓冲流内部缓冲区的大小,不指定默认

+ 使用方法:
  1. 创建FOS对象
  2. 创建缓冲流, 构造方法中传递FOS对象, 提高FOS效率
  3. 使用BOS对象, 把数据写入缓冲区
  4. 使用flush, 把数据刷新到文件中(可省略)
  5. 释放资源

## 7.3 字节缓冲输入流

+ 构造方法
  `BufferedInputStream(InputStream in)`创建一个新的緩冲输出流,以将数据写入指定的底层输岀流。
  `BufferedInputStream(InputStream in, int size)`创建一个新的缓冲输出流,以将具有指定缓冲区大小的数据写入指定的底层输出流
  + 参数:
    InputStream in:字节输入流
    int size:指定缓冲流内部缓冲区的大小,不指定默认

+ 使用方法:
  1. 创建FIS对象
  2. 创建缓冲流BIS, 构造方法中传递FIS对象, 提高FIS效率
  3. 使用BIS对象read 方法, 读取文件
  4. 释放资源

![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1621420492611-1621420492545.png)



## 7.4 字符缓冲输出流

+ 构造方法

  `BufferedWriter(Writer out)`

  `BufferedWriter(Writer out, int sz)`

+ **特有的成员方法**

  `newLine()`: 写一个行分隔符, 会根据不同操作系统获取不同行分隔符

+ 使用步骤
  1. 创建BW, 传递Writer
  2. 调用write, 写入缓冲区
  3. flush
  4. close



## 7.5 字符缓冲输入流

+ 构造方法

  `BufferedReader(Reader in)`

  `BufferedReader(Reader in, int sz)`

+ **特有的成员方法**

  `readLine()`: 读写一行文本, 通过换行符判断终止, 返回值包含该行内容的**字符串**, 不包含换行符, 如果已经到末尾, 返回null(不是-1)

+ 使用步骤
  1. 创建BR, 传递FileReader
  2. 调用read, 读入缓冲区
  3. flush
  4. close



# 第八章 转换流

## 8.1 字符编码和字符集

字符编码: 自然语言与二进制的对应规则

### 字符集

+ 字符集`charset`: 也叫编码表, 是一个系统支持的所有字符的集合

+ 常见字符集: ASCII, GBK, Unicode(UTF8 16 32)

  + ASCII字符集:

    美国用的, 长度: 7bits, 共128个; 扩展字符集长度8bits, 共256个

  + ISO-8859-1:

    拉丁码表, 欧洲人用的, 单字节编码, 兼容ASCII

  + GBxxx:

    GB2312: 简体中文码表, 小于127就是ASCII, 2个大于127的字节, 加一起是一个汉字

    GBK: 最常用, 支持繁体, 日韩汉字(Windows默认)

    GB18030: 在2312上扩展出的, 最新, 可以由1个, 2个, 4个字节组成

  + Unicode:
    + 万国码, 业界标准, 又叫统一码, 标准万国码
    + 最多4个字节, 有3种方案, 8, 16, 32
    + 最常用: UTF-8, 使用web开发也要用这个, 它使用1-4个字节进行编码
      1. 128个ASCII字符, 1个字节
      2. 拉丁文等, 2个字节
      3. 大部分常用字(含中文), 3个字节
      4. 其他极少Unicode辅助字符, 4个字节



## 8.2 OutputStreamReader类

FileReader可以读取IDE格式的编码, 但读取默认编码格式(GBK)会乱码(编码解码方式不同). 

+ `InputStreamReader`/ `OutputStreamWriter` 可以指定编码表, 

+ `FileReader` / `FileWriter `只能使用IDE默认编码(UTF-8)

+ 构造方法
  `Outputstreamwriter(OutputStream out)`创建使用默认字符编码的 outputstreamwriter 
  `Outputstreamwriter(OutputStream out, String charsetName)`创建使用指定字符集的OutputStreamWriter
  + 参数
    `Outputstream out`:字节输出流,可以用来写转换之后的字节到文件中
    `String charsetName`:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8, gbk/GBK ...不指定, 默认使用UTF-8
+ 使用步骤
  1. 创建OutputStreamWriter对象, 传递字节输出流FOS和指定编码表名称
  2. 使用OutputStreamWriter对象的write, 把字符转化为字节, 存储到缓冲区
  3. flush
  4. close



## 8.3 InputStreamReader类

+ 构造方法
  `Inputstreamwriter(OutputStream out)`创建使用默认字符编码的 Inputstreamwriter 
  `Inputstreamwriter(OutputStream out, String charsetName)`创建使用指定字符集的OutputStreamWriter
  + 参数
    `Outputstream out`:字节输出流,可以用来写转换之后的字节到文件中
    `String charsetName`:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8, gbk/GBK ...不指定, 默认使用UTF-8
+ 使用步骤
  1. 创建InputStreamWriter对象, 传递字节输出流FIS和指定编码表名称
  2. 使用InputStreamWriter对象的read, 把字符转化为字节, 读取文件  
  3. close



# 第九章 序列化

## 9.1 概述

+ 把对象以流的方式写入文件中, 叫做写对象, 也叫做对象的序列化

  对象中包含的不仅是字符, 还有字节, 要用字节流

  `ObjectOutputStream`: 对象序列化类

  `writeObject(p)`: 写入对象

+ 把文件中保存的对象, 读取出来, 叫对象的反序列化

  读取的都是字节, 用字节流

  `ObjectInputStream`: 对象反序列化类

  `readObject()`: 返回一个Object

  

## 9.2 ObjectOutputStream类

+ 构造方法:

  `public ObjectOutputStream(OutputStream out)`: 创建一个指定OutputStream的OOS

+ 特有的成员方法:

  `writeObject(Object obj)`将指定对象写入ObjectOutputStream

+ 使用步骤

  1. 创建OOS对象, 传递字节输出流
  2. 使用OOS对象的方法writeObject, 把对象写入文件
  3. close

+ 注意:

  写入的对象必须实现`Serializable`接口(是一个**标记接口**, 没有任何需要实现的方法)



## 9.3 ObjectInputStream类

+ 构造方法:

  `public ObjectInputStream(InputStream out)`: 创建一个指定OutputStream的OOS

+ 特有的成员方法:

  `readObject(Object obj)`从指定流中读取对象

+ 使用步骤

  1. 创建OIS对象, 传递字节输入流
  2. 使用OIS对象的方法readObject, 读取对象, 用Object接受
  3. close
  4. 使用读取的对象

+ 注意

  1. 类必须实现`Serializable`接口
  2. 必须存在类对应的class文件

### 静态与瞬态

+ static关键字: 静态

  静态优先于非静态加载到内存中

  被static修饰的成员变量不能被序列化, 因为它不属于成员(序列化可以正常进行, 但是不存该数据)

+ transient关键字: 瞬态

  被transient关键字修饰的成员变量不能被序列化

### InvalidClassException

+ 如果反序列化时能找到class文件, 但是class文件已经被修改, 会抛出`InvalidClassException`

![image-20210520000857741](../../../../Pictures/PicBed/MDImage/image-20210520000857741.png)

+ 解决方案: 手动给类添加序列号

  显式声明`static final long serialVersionUID= 12345L`, 可以再加个private



## 9.4 打印流

`java.io.PrintStream`打印流, 为其他输出流添加了功能, 可以打印各种数据值表示形式

+ 特点
  1. 只负责输出, 不负责读取
  2. 不会抛出IOException
  3. 有特有方法, `print(任意值)`, `println(任意值)`

### 构造方法

+ `PrintStream(File file)`: 输出目的地是一个文件
+ `PrintStream(OutputStream)`: 输出目的地是一个字节输出流
+ `PrintStream(String fileName)`: 输出目的地是一个文件路径

### 继承父类的成员方法

- `close()`
-  `flush()`, 
- `write(byte[] b)`, 
- `write(byte[] b, int off, int len)`, 
- `write(int b)`

+ 注意:
  1. 如果使用继承自父类的`write()`写数据, 那么查看数据的时候会查询编码表 97 -> a
  2. 如果使用自己特有的方法`print()`, `println()`写数据, 写的数据原样输出 97 -> 97

### 改变输入目的地

也叫改变打印流的流向

+ `System.out`输出语句默认在控制台输出
+ `System.setOut(PrintStream out)`改变输出语句的目的地为参数传递的打印流目的地



# --------------------

# 第七部分 网络编程

# 第一章 网络编程入门

## 1.1 软件结构

+ C/S结构: 全程文Client/Server结构, 指客户端和服务器结构
+ B/S结构: Browser/Server结构, 指浏览器和服务器结构
+ 各有优势, 但都需要网络的支持
+ 网络编程是指在一定协议下实现两台计算机通信的程序



## 1.2 网络通信协议

+ 位于同一个网络的计算机在进行连接和通信时需要遵守一定规则, 这些规则被称为网络通信协议, 她对数据的传输格式, 传输速率, 传输步骤等做了统一规定. 
+ TCP/IP协议(重点)
+ UDP协议



## 1.3 协议分类

+ UDP: 用户数据报协议, 是无连接通信协议, 发送数据时不用建立连接, 发送端不会确认接收端是否存在, 接收端不会反馈是否收到. 
  + 优点: 消耗资源小, 通信效率高, 通常用于音频, 视频和普通数据的传输
  + 缺点: 不能保证数据的完整性, 不能传输重要数据
  + 特点: 数据被限制在64kb以内
  + 数据报: 网络传输的基本单位
+ TCP: 传输控制协议, **面向连接**的通信协议, 提供两台计算机之间无差错的数据传输
  + 三次握手: 
    1. 第一次握手, 客户端向服务器发出请求, 等待确认
    2. 第二次握手, 服务器向客户端会送一个响应, 通知收到了连接请求
    3. 第三次握手, 客户端再次向服务器发送确认信息, 确认连接
  + 三次握手之后, 可以开始进行传输. 



## 1.4 网络编程三要素

### 协议

见1.3

### IP地址

+ 指互联网协议地址
+ 分类
  + IPv4: 4个字节组成, 是32位的二进制数, 通常被分为4个字节, 表示成`a.b.c.d`, 都是0-255, 有42亿个
  + IPv6: 16个字节组成, 128位, 每16位一组
+ 常用命令
  + `ipconfig`: 查看本机ip地址
  + `ping ip地址`查询网络是否连通
+ 特殊ip地址
  + 本机ip: `127.0.0.1`, `localhost`

### 端口号

+ 由两个字节组成, 取值0-65535之间
+ 注意: 
  1. 1024之前的端口不能使用, 已经被系统分配给已知软件
  2. 网络软件端口号不能重复
+ 常用端口:
  1. `80`端口: 网络端口, www.baidu.com:80
  2. 数据库: MySQL: 3306, Oracle: 1521
  3. Tomcat服务器: 8080



# 第二章 TCP通信程序

## 2.1 概述

TCP通信能实现两台计算机的数据交互, 通信的两端要严格区分为客户端(client)与服务端(server)

+ 两端通信步骤

  1. 服务器先启动, 等待客户端连接
  2. 客户端主动连接服务器, 成功才通信, 服务器不能主动连接客户端

  这个连接中**包含了一个IO对象**, 通信的数据不仅是字符, 所以IO对象是一个**字节流对象**

+ 服务器端必须明确两件事

  1. 多个客户端同时和服务器进行交互, 服务器必须明确和哪个客户端进行的交互

     在服务器端有一个方法`accept()`, 可以返回请求的客户端对象

  2. 多个客户端同时和服务器进行交互, 就需要多个IO流对象

     服务器没有IO流, 服务器可以获取到请求的客户端对象Socket, 使用每个**客户端提供的IO流**, 和客户端进行交互

+ 在Java中,提供了两个类用于实现TCP通信程序:

  1. 客户端: `java.net. Socket`类表示。创建 Socket对象, 向服务端发出连接请求,服务端响应请求, 两者建立连接开始通信。
  2. 服务端: `java.net. ServerSocket`类表示。创建 ServerSocket对象, 相当于开启一个服务, 并等待客户端的连接。



## 2.2 Socket类

实现客户端套接字. 套接字是两台机器间通信的端点, 包含了IP地址和网络端口的网络单位.

+ 构造方法: 

  `Socket(String host, int port)`

  参数: 

  1. String host: 服务器主机名称/IP地址
  2. int port: 服务器端口号

+ 成员方法

  1. `OutputStream getOutputStream()`: 返回此套接字的输出流
  2. `InputStream getInputStream()`
  3. `void close`

+ 实现步骤

  1. 创建一个客户端对象Socket, 绑定IP和端口
  2. 使用Socket中的getOutputStream, 获取输入流
  3. 使用网络字节输出流OutputStream中的方法write, 向服务器发送数据
  4. 获取InputStream
  5. 使用InputStream中的read, 读取服务器回写的数据
  6. close

+ 注意

  1. 客户端和服务器端进行交互, 必须使用Socket提供的网络流, 不能使用自己创建的流对象

  2. 创建Socket的时候, 就会去和服务器经过三次握手, 建立连接

     这时如果服务器没有启动, 就会抛出异常`ConnectException`

     如果已经启动, 就会进行交互



## 2.3 ServerSocket服务器类

+ 构造方法

  `ServerSocket(int port)`创建指定端口的服务器套接字

+ 服务器必须指定是哪个客户端请求的服务器, 可以使用`accept()`获取请求服务器的客户端

+ 成员方法: 

  `Socket accept()`: 侦听并接受到此套接字的连接

+ 服务器的实现步骤: 

  1. 创建服务器ServerSocket对象, 指定端口号
  2. 使用`accept()`, 获取到请求的客户端对象
  3. 使用`getInputStream()`获取输入流
  4. 使用is中的read, 读取客户端发送的数据
  5. 获取输出流os
  6. 使用os的方法write, 回写数据
  7. close释放资源(Socket, ServerSocket)



## 2.4 文件上传案例

+ Socket中fis不会读取文件终止符, 需要在while循环后面加上: 

  ```java
  socket.shutdownOutput();
  ```

  否则会导致ServerSocket中fos无法终止

+ 优化: 

  1. ServerSocket中FOS路径写死了, 不管上传什么, 最终都会覆盖同一个文件

     解决: 自定义文件命名规则, 如 域名+ 毫秒值+随机数

     ```java
     String fileName = "SalmonC" + System.currentTimeMills() + new Random.nextInt(999999) + ".jpg";
     ```

  2. 上传一张图片就停止了

     解决: 让服务器一直处于监听状态(死循环accept方法至释放资源, 不释放ServerSocket)

  3. 使用多线程, 提高效率, 每有一个客户端上传, 就开启一个线程

     run方法没有声明抛出, 所以子类要try catch



## 2.5 模拟B/S程序

+ 步骤

  1. 创建ServerSocket
  2. socket = accept()
  3. is = getInputStream()
  4. read()读取请求信息

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622024042069-1622024042026.png)

+ 固定返回信息

  先用socket的OutputStream write以下内容

  ```java
  // 写入HTTP协议响应头,固定写法
  os.write("http:/1.1200Ok\r\n".getBytes());
  os.write("Content-Type: text/html\r\n".getBytes();
  // 必须要写入空行,否则浏览器不解析
  os.write("\r\n"getBytes());
  ```

+ 浏览器解析服务器回写的html页面, 如果页面有图片, 浏览器就会单独开一个线程去读取图片, 所以需要服务器保持监听状态, 并开启多线程



# 第三章 函数式接口

## 3.1 概念

函数式接口是指: **有且仅有一个抽象方法的接口**, (可以包含其他默认, 静态, 私有方法)可用于Lambda使用

## 3.2 格式

```java
修饰符 interface 接口名称{
    public abstract 返回值类型 方法名称(可选参数信息);
}
```

接口方法中的`public abstract`可以**省略**



## 3.3 @FunctionalInterface注解

```java
@FunctionalInterface // 检测是否为函数式接口
修饰符 interface 接口名称{
    public abstract 返回值类型 方法名称(可选参数信息);
}
```

注解作用: 检测是否满足注解, 否则编译失败(如`@Override`, `@FunctionalInterface`)



## 3.4 函数式接口的使用

+ 函数式接口一般可以作为方法的**参数**和**返回值**类型

+ 如果参数是函数式接口: 

  1. 可以传递实现类对象
  2. 可以传递接口的匿名内部类
  3. 可以传递Lambda表达式

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622025345810-1622025345781.png)



# 第四章 函数式编程

## 4.1 Lambda的延迟执行

有些场景的代码执行后, 结果不一定被使用, 从而造成性能浪费. Lambda表达式是延迟执行的, 可以作为解决方案, 提升性能





# 第五章 Junit

## 5.1 测试分类

+ 测试分为黑盒和白盒
  + 黑盒: 不知道实现原理, 只需要知道input和output, 不需要写代码
  + 白盒: 需要知道具体关注具体流程, 需要写代码



## 5.2 Junit的使用

Junit是白盒测试

+ 使用步骤

  1. 定义一个测试类(测试用例)

     建议: 

     1. 测试类名: 被测试的类名Test     CalculateTest
     2. 包名: xxx.xxx.test     cn.itcast.test

  2. 定义测试方法: 可以**独立运行**

     建议: 

     1. 方法名: test测试方法名     testAdd()
     2. 返回值 void
     3. 参数列表: 建议空参

  3. 给方法加一个注解 `@test`

  4. 导入Junit依赖环境

+ 判定结果: 

  1. 红色失败, 绿色成功, 不看输出

  2. 断言`assert`, 判断期望值与真实值是否相同, 不同会报错, 抛出**Error**. 

  ```java
  Assert.assertEquals(expected, result);
  ```

+ 初始化方法`init()`, 用于资源申请, 所有测试方法执行前都要执行该方法, 在前面加`@Before`

  释放资源方法: 所有方法执行完后都执行该方法, 在前面加`@After`, 相当于finally

  ```java
  @Before
  public void init(){
      
  }
  ```



# 第六章 反射

+ 反射被称为框架设计的灵魂

+ 框架: 半成品软件, 可以在框架基础上开发软件, 简化编码

## 6.1 概念

+ 反射: 将类的各个组成部分封装为其他对象, 这就是反射机制
+ 好处: 
  1. 在程序运行过程中操作这些对象. (比如写代码时自动提示方法)
  2. 可以解耦, 提高程序可拓展性



## 6.2 使用

+ 获取class的三种方式

  1. `Class.forName(全类名)`: 将字节码文件加载进内存, 返回class对象. 全类名从src下一级开始

     + 体现了反射的动态性

     + 多用于配置文件, 将类名定义在配置文件中, 读取文件, 加载类

  2. 如果已经加载进内存了, 通过类名的属性class来获取`Student.class`

     + 多用于参数传递

  3. 已经创建对象了, 使用`对象.getClass()`

  + 同一个字节码文件在一次程序运行中只加载一次, 无论哪种方式获取的class对象是同一个. 

  4. (了解) `ClassLoader`: 类的加载器

     ```java
     ClassLoader classLoader = ReflectionTest.class.getclassLoader();
     Class clazz4 = classLoader.loadClass("com.atguigu.java.Person")
     ```

+ 疑问: 

  1. new或者反射都能调用公共结构, 开发用哪个?

     直接new. 反射特点: 动态性. 编译时不确定new哪个对象, 使用反射

  2. 反射与封装是否矛盾

     **不矛盾**. 

+ ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622046407749-1622046407683.png)

## 6.3 类加载器

+ 使用类加载器+Properties读取配置文件

  ![](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1622048104084-1622048104067.png)

  直接使用properties, 默认位置是在module下; 使用加载器, 默认位置在当前module的src下(更进一层目录)

## 6.4 创建运行时类对象(重点)

+ 方法:

  1. 使用`newInstance()`创建对象, 实际上调用的空参构造, 没有空参构造会报错, 空参构造权限不够会报错.  

     在Javabean中要求提供public空参构造器, 便于通过反射创建运行时类对象, 便于子类继承此运行时类时, 默认调用`super()`时保证父类有此构造器

  2. 使用指定构造器

```java
// 方法1 newInstance()
psvm{
    Class clazz = Person.class;
    Person p = (Person) class.newInstance();
}
// 或
psvm{
    Class<Person> clazz = Person.class;
    Person p = class.newInstance();
}
```



## 6.5 获取当前运行时类属性

### 获取属性结构Field

`getFields()`: 获取当前运行时类及其父类所有声明为`public`权限的属性

`getDeclaredFields()`: 获取所有声明的所有属性, 不考虑权限, **没有父类的属性**

```java
Class clazz = Person.class;
Field[] fields = clazz.getFields();
for(Field f : fields){
    sout(f); //只出public权限的属性, 父类的属性也会出来
}
```

+ 获取属性中的具体结构: 权限修饰符/ 数据类型/ 变量名

  ```java
  Class clazz = Person.class;
  Field[] declaredFields = clazz.getDeclaredFields();
  for(Field f : declaredFields){
  	// 1. 权限修饰符
      int modifier = f.getModifiers(); 
      sout(modifer); // 1:public; 2:private; 4:protected...
      // 可以在Modifier类中查询对应(shift shift查找, command + 7查看所有方法)
      sout(modifier.toString()); // 直接打印文字, 空白表示default
      
      // 2. 数据类型
      Class type = f.getType(); //返回一个类
      sout(type.getName); // 会显示全类名"java.lang.String", 使用getName(), 否则类名称前面会有一个"class"
      
      // 3. 变量名
      String fName = f.getName();
      sout(fName);
      
  }
  ```

+ 实际开发中几乎不会干这个



### 获取方法Method

`getMethods()`: 获取当前运行时类及其父类所有声明为`public`权限的方法

`getDeclaredMethods()`: 获取所有声明的所有方法, 不考虑权限, **没有父类的方法**

```java
Class clazz = Person.class; //要导包

Method[] methods = clazz.getMethods(); //获取的只有public, 包含所有父类方法
for(Method m : methods){
    sout(m); // 打印结果: 修饰符 全类名.方法名(参数)
}
```

+ 获取方法的内部结构

  ```java
  // 1. 获取方法的注解, 不能获取source, class, 只能获取runtime
  for(Method m : methods){
      Annotation[] annos = m.getAnnotations();
      for(Annotation a : annos){
          sout(a);
      }
      
      // 2. 权限修饰符
  	// 使用getModifiers(), 同属性
      
      // 3. 返回值类型
      Class returnType = m.getReturnType().getName();
  
  	// 4. 方法名
      String mName = m.getName();
      
      // 5. 形参列表
      Class[] pTypes = m.getParameterTypes();
      for(i) sout(pTypes[i] + " args_" + i);
      
      // 6. 抛出的异常 throws xxx
      Class[] exceptionTypes = m.getExceptionTypes();
      
  }
  ```

+ 框架 = 注解 + 反射 + 设计模式





### 获取构造器

`getConstructors()`: 获取当前运行时类所有声明为`public`权限的构造器, **没有父类的构造器**

`getDeclaredConstructors()`: 获取所有声明的所有构造器, 不考虑权限, **没有父类的构造器**



```java
Class clazz = Person.class;
Constructor[] constructors = clazz.getConstructors();
for(){
    sout(c); //修饰符 全类名(参数的全类名/基本数据类型)
}
```



### 获取运行时类带泛型的父类

`getSuperclass()` 获取父类, 不带泛型

`getGenericSuperclass()`

```java
// 不带泛型的父类
Class clazz = Person.class;
Class superclass = clazz.getSuperclass();

// 带泛型父类
Type genericSuperclass = clazz.getGenericSuperclass(); // Type是一个接口
sout(genericSuperclass); // 全类名(泛型的全类名)

// 带泛型父类的泛型
ParameterizedType paramType = (ParameterizedType) genericSuperclass; 
	// 获取泛型类型
Type[] paramType.getActualTypeArguments();
sout(paramType[0]); // class 泛型的全类名, 可用 getTypeName()去除前面的class, 或者强转为class再getName()
```



### 获取实现的接口

`getInterface()`: 返回一个数组(多实现), 不包含父类的接口; 对于父类的接口, 需要先得到父类, 再查询. 



### 获取所在的包

`getPackage()`: 返回Package类, 打印为`package 包名`



### 获取运行时类注解

`getAnnotations()`: 同获取方法的注解, 返回一个Annotation类数组, 



## 6.6 使用场景: 动态代理

+ 动态代理: 编译的时候不指明代理类, 运行时根据被代理类, 动态地制造一个代理类: 
  + 拿到被代理类实现的接口, 自己也实现该接口



## 6.7 调用运行时类的指定结构(重点)

### 调用属性

主要是指属性和方法, 有时构造器, 最重要的是方法. 

属性调用一般分为两方面: 获取值, 设置值. 

+ `getDeclaredField(String name)`: 获取**类**中的指定名字的属性. (clazz.get);
+ `set(Object obj, Object value)`: 将指定实例的**属性**设置为指定值. (id.set);
+ `setAccessible(booleanb)`: 对非public的**属性**设置访问权限

```java
public class ReflectionTest {
    
    
    public void testField(){
        Class clazz = Person.class;
        
        // 创建运行时类对象
        Person p = (Person) clazz.newInstance(); //抛异常
        
        // 获取指定属性
        clazz.getDeclaredField("id");
        
        /* 设置值
        set的参数1: 设置的哪个对象, 参数2: 设置的值
        get的参数: 获取哪个对象的当前属性值
        只能get public的属性, 需要先对属性setAccessible(true)*/
        id.setAccessible(true);
        id.set(p, 1001);
        int pId = id.get(p);
    }
}
```



### 操作运行时类的指定方法

+ 步骤
  1. `getDeclaredMethod(String name, Class<?>... parameterTypes)`获取指定的某个方法, 参数2为方法的参数列表(如果有重载), 用`xxx.class`
  2. `setAccesible()`设置权限
  3. `invoke(Objecet obj, Object... args)` 调用方法, 第一个参数的调用者(普通方法为实例, 静态方法为类或者null), 第二个为参数列表
+ 静态方法: 



```java
public class ReflectionTest {
    
    public void testField(){
        Class clazz = Person.class;
        Person p = (Person) clazz.newInstance();
        
        // 1. 获取指定方法
        Method show = clazz.getDeclaredMethod("show", String.class);
        
        // 2. 设置权限
        show.setAccessible(True);
        
        /* 3. 调用方法
        invoke()的返回值为原方法的返回值, 类型为Object, 可以强转; void则返回null
        */
        String str = (String) show.invoke(p, "CHN");
        String str2 = (String) showDesc.invoke(Person.class); //静态方法
        
    }
        
}
```



### 调用指定构造器(不常用)

常用`newInstance()`, 调用空参构造器

+ 步骤
  1. `getDeclaredConstructor(Class<?>... parameterTypes)`获取指定的某个方法, 参数为构造器的参数列表, 用`xxx.class`
  2. `setAccessible()`
  3. `newInstance()`













# --------------------

# 附录1 IDEA的快捷用法

+ psvm 回车，快捷输入：

```java
public static void main(String[] args){

}
```

+ alt + / ：自动补全
+ alt + enter : 处理异常
+ cmd + alt + L格式化代码
+ 循环次数n + .fori：自动生成for循环n次 
+ 循环次数n + .forr：自动生成for循环n次循环时为倒序（`i = xxx.length -1, i--）
+ shift + alt + 上下方向键：将当前行代码上下移动
+ shift + return: 换行(光标后内容忽略)
+ control + O: 重写方法
+ shift + F6: 批量修改变量名

# 附录2 报错

>`Exception`：异常  
>`Error`：报错  
>`类.java:[数字]`：#第几行出现问题
>`Variable 'xxx' might not have been initialized`：局部变量未赋值

