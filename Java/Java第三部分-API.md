# 第一章 API

## 概述

API(Application Programming Interface)，应用程序编程接口。Java API是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们只需要学习如何使用。

## 使用

打开JDK API文件，在索引中搜索想看的*类*，点击后主要查看3个内容：

1. 所在的包路径，写在标题上方；
2. 构造方法；
3. 方法摘要。



# 第二章 Scanner类

## 2.1 什么是Scanner类

一个可以解析基本类型和字符串的简单文本扫描器。可以实现键盘输入数据到程序当中。

## 2.2 引用类型的使用

+ 一般步骤：

  1. 第一步：导包
     如果需要使用的目标类和当前类位于同一个包，则可以省略导包。lung包不需要import。
     import 包路径.类名称;
  2. 第二步：创建
     类名称 对象名 = new 类名称();
     System.in代表从键盘进行输入

  3. 第三步：使用
     对象名.成员方法名()  

     获取键盘输入的一个int数字：int num = sc.nextInt();
     获取键盘输入的一个int数字：String str = sc.next();

## 2.3 匿名对象

### 概念

+  创建对象的标准格式：

  ```java
  类名称 对象名 = new 类名称();
  ```

+ 匿名对象：只有右边的对象，没有左边的名字和赋值运算符：

  ```java
  new 类名称();
  ```

+ 匿名对象只能使用唯一一次，再用时只能再创建新对象。如果有一个对象只需要使用一次，可以使用匿名对象。

### 应用

+ 匿名对象进行传参

  ```java
  public static void methodParam(Scanner sc){
    ...
  }
  ```

+ 匿名对象作为返回值

  ```java
  public static Scanner methodReturn(){
    return new Scanner(Systenm.in);
  }
  ```

  

# 第三章 Random类

## 应用

+ 用途：生成随机数字

+ 使用过程：也是三个步骤

  1. 第一步：导包

     `import Java.util.Random;`

  2. 第二步：创建

     `Random r = new Random()`

  3. 第三步：使用

     获取一个随机的int数字，范围是int所有范围：`nextInt()`

     获取一个随机的int数字，以参数限定范围：`nextInt(a)`范围：[0, a)，即0~(a-1)，参考数组索引。



# 第四章 ArrayList类

数组长度不可以改变，但ArrayList集合可以。

## 泛型

+ 对于ArrayList，有一个<E>代表泛型。

+ 泛型：装在集合中的所有元素，全都是统一的什么类型，如：元素全都是String等。

  注意：泛型只能是引用类型，不能是基本类型。即只能储存地址值。

## 使用

+ 对于ArrayList来说，直接打印得到的不是地址值，而是内容；如果内容是空，打印出的是空的[ ]。

+ 常用方法：

|  方法   |     参数      |           返回值            |       作用       |
| :-----: | :-----------: | :-------------------------: | :--------------: |
|  .add   | E，与泛型一致 |    boolean，是否成功执行    |     添加内容     |
|  .get   | int，索引编号 | E，索引对应内容，与泛型一致 |     读取内容     |
| .remove | int，索引编号 | E，索引对应内容，与泛型一致 |  读取并删除内容  |
|  .size  |      无       |   int，集合包含的元素个数   | 获取集合尺寸长度 |

+ 对于ArrayList来说，add一定成功，返回值可用可不用；

+ 可用list.size遍历集合：

  ```java
  for (int i = 0; i < list.size(); I++){ // 也可直接用list.fori。注意不是list.length
    System.out.println(list.get(i));
  }
  ```

+ ArrayLIst只能储存地址值，如果需要储存基本类型数据，需要使用其包装类：

  | 基本类型 |    包装类     |
  | :------: | :-----------: |
  |   byte   |     Byte      |
  |  short   |     Short     |
  | **int**  |  **Integer**  |
  |   long   |     Long      |
  |  double  |    Double     |
  | **char** | **Character** |
  | boolean  |    Boolean    |

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(100);
```



+ 从JDK 1.5+开始，支持自动装箱、自动拆箱：  
  + 自动装箱：基本类型-->引用类型
  + 自动拆箱：引用类型-->基本类型



# 第五章 String类

API中说，`String`类代表字符串。 Java程序中的所有字符串文字（例如`"abc"` ）都被实现为此类的实例。

也就是说，程序当中所有双引号字符都是`String`类的对象。（即使没有new也是）



## 5.1 特点

1. 字符串是**常量**，内容永不可变。【重点】
2. 因为字符串不可改变，所以字符串可以共享使用。
3. 字符串效果上相当于char[ ]字符数组，但是底层原理是byte[ ]字节数组。



## 5.2 创建

常见3种构造方法，1种直接创建：

```java
//第一种构造方法，创建一个空白字符串，不含有任何内容
public String()

//第二种构造方法，根据字符数组的内容创建对应字符串
public String(char[] array)
    
//第三种构造方法
public String(byte[] array)
    
//直接创建
String str = "Hello"
```



## 5.3 常量池

+ 字符串常量池在**堆**中。
+ 程序中直接写上的双引号字符，就在字符串常量池中；`new`的字符串不在常量池中。

+ 对于基本类型，`==`是比较数值；对于引用类型，`==`是比较地址值。



## 5.4 常用方法

+ 比较字符串内容：

  1. ```java
     public boolean equals(Object obj)
     ```

     + 参数可以是任何**对象**，只有参数是字符串且相同，才会返回true；

     + equals具有对称性，即`a.equals(b)`和`b.equals(a)`效果一样；

     + 如果比较双方一个常量一个变量，推荐把常量字符串写在前面，如：

       推荐：`"abc".equals(str1)`

       不推荐：`str1.equals("abc")`

       因为变量为`null`时前者返回`false`，后者报错空指针异常`NullPointerException`

  2. ```java
     public boolean equalsIgnoreCase(String str)
     ```

     + 忽略大小写进行内容比较。

       

+ 获取相关

  ```java
  //获取字符串当中含有的字符个数，拿到字符串长度；
  public int length()
  
  //将当前字符串和参数字符串拼接为新的字符串，return；如果有null，会空指针异常
  public String concat(String str)
  
  //获取指定索引位置的单个字符
  public char charAt(int index)
  
  //查找参数字符串在本字符串中首次出现的索引位置，没有则返回-1值
  public int indexOf(String str)
  ```

  

+ 截取相关

  ```java
  // 截取从参数位置一直到字符串末尾，返回新字符串
  public String substring(int index)
  
  // 截取从begin开始，end结束，中间的字符串，[begin, end)，包含左边，不包含右边
  public String substring(int begin, int end)
      
  // 注意：截取之后原字符串不发生变化。
  ```

  

+ 转换相关

  ```java
  // 将当前字符串拆分成为字符数组，return
  public char[] toCharArray()
  
  // 获得当前字符串底层的字节数据
  public byte[] getBytes()
      
  // 将所有出现的老字符串(oldString)替换为新字符串(newString)，返回新的字符串
  // CharSequence意思是可以接受字符串类型，可以看做String
  public String replace(CharSequnce oldString, CharSequence newString)
  ```



+ 分隔

  ```java
  // 按照参数规则，将字符串切分成为若干部分
  public String[] split(String regex)
  ```

  + split方法参数是正则表达式(regex)，"."等符号需要`\\`进行转义



# 第六章 static静态关键字

## 6.1 static field

+ 使用了static关键字的内容不再属于对象自己，而是属于类，所以凡是属于本类的对象都共享同一份。
+ 给其中一个赋值，其他所有对象都会改变



## 6.2 static method

+ 使用方法
  1. 一旦使用static修饰成员方法，就成为了静态方法。
  2. 静态方法不属于对象，而是属于类。
  3. 如果没有static关键字，则必须先创建对象才能使用。
  4. 对于静态方法，可以通过对象名进行调用（不推荐），也可以通过**类名称**进行调用。
  5. 无论是**静态变量**还是**静态方法**，都推荐使用类名称进行调用。
  6. 对于**本类当中的*静态*方法**，可以省略类名称。

+ 注意事项
  1. 静态不能直接访问非静态：如静态方法不能直接访问成员变量，因为在内存中**先**有静态，**后**有非静态内容；
  2. 静态方法中不能用this：this代表当前对象，但静态方法和对象无关。
  3. 

## 6.3 静态代码块

+ 格式：

```java
public class 类名称{
    static{
        // 静态代码块内容
    }
}
```

+ 特点：当**第一次**用到本类，静态带麦克执行**唯一**的一次。
+ **静态内容总是优先于非静态**，静态代码块比构造方法优先执行。
+ 静态代码块的典型用途：用于一次性地对静态成员变量赋值。



# 第七章 Arrays类

Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用来实现数组常见的操作。

常用方法：

+ `public static String toString(Array)`：将参数数组变成字符串，按照默认格式：[元素1, 元素2, 元素3 ...]。

+ `public static void sort(Array)`：对数组元素进行排序，按照默认升序。

  ```java
  public static void main(String[] args){
      int[] array1 = {2, 1, 3, 5, 12};
      Arrays.sort(array1);
      System.out.println(Arrays.toString(array1)); //[1, 2, 3, 5, 12]
  }
  ```

  + 如果是数值，`sort`默认按照从小到大；
  + 如果输字母，默认按照字母升序；
  + 如果是自定义类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。



# 第八章 Math类

java.lang.Math 类是数学相关的工具类，里面有大量的静态方法，完成与数学运算相关的操作。

常用方法

+ `public static double abs(double num)`：获取绝对值。
+ `public static double ceil(double num)`：向上取整。
+ `public static double floor(double num)`：向下取整。
+ `public static long round(double num)`：四舍五入。
+ `Math.PI`：代表近似圆周率



# 第九章 抽象类

## 9.1 概述

如果父类当中的方法不确定如何进行方法体实现，这就是一个抽象方法。

![抽象方法](https://cdn.jsdelivr.net/gh/SalmonC/PicBed@main/1612869913823-1612869913794.png)

## 9.2 定义与使用

+ 抽象方法：加上`abstract`关键字，去掉大括号，直接分号结束。

  ```java
  public abstract void eat();
  ```

+ 抽象类：抽象方法所在的类必须是抽象类，在class之前写上abstract即可。

+ 使用：

  1. 不能直接创建new抽象类对象；

  2. 必须用一个子类来继承抽象父类；

  3. 子类必须覆盖重写抽象父类当中所有的抽象方法；

     覆盖重写（实现 implements）：去掉抽象方法的`abstract`，然后补上方法体。

## 9.3 注意事项

1. 抽象类**不能创建对象**；
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员用的；
3. 抽象类中，不一定包含抽象方法，但有抽象方法的一定是抽象类；
4. 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则编译无法通过，除非子类也是抽象类。



# 第十章 接口(interface)

接口是一种公共的规范标准。

只要符合规范标准，就可以大家通用。



## 10.1 基本格式

+ 接口就是多个类的公共规范。

+ 接口是一种引用数据类型，最重要的内容就是其中的**抽象方法**。

+ 如何定义一个接口格式：

  ```java
  public interface 接口名称{
      接口内容;
  }
  ```

  备注：关键字class换成interface之后，编译生成的字节码文件仍然是 .java --> .class。

+ 如果是java7，那么接口中可以包含的内容有：
  1. 常量
  2. 抽象方法
+ 如果是java8，还可以**额外包含**有：
  3. 默认方法
  4. 静态方法
+ 如果是java9，还可以**额外包含**有：
  
  5. 私有方法



## 10.2 各种方法的定义与使用

### ①抽象方法(abstract)

在任何的java版本中，接口都能定义抽象方法。

格式：

```java
public abstract void 方法名();
```

注意事项：

1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：`public`、`abstract`；
2. 这两个关键字修饰符，可以选择性地**省略**；
3. 方法的三要素（方法名、参数、返回值）可以随意定义。

使用

1. 接口不能直接使用，必须有一个“实现类”来“实现（implements)”该接口。

   格式：

   ```java
   public class 实现类名称 implements 接口名称{
       
   }
   ```

2. 接口的实现类必须覆盖重写接口中所有的抽象方法。

   实现：去掉`abstract`关键字，加上方法体大括号。

3. 创建实现类的对象，进行使用。不能直接new接口对象！

注意事项：

如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类必须是**抽象类**。



### ②默认方法(default)

从java8开始，接口里允许定义默认方法。

格式：

```java
public default 返回值类型 方法名称(参数列表){
    方法体;
}
```

备注：

接口当中的默认方法可以解决接口升级的问题，不用再去每个子类里实现。

使用

1. 默认方法会被实现类**继承**；

2. 接口的默认方法，可以通过接口实现类对象**直接调用**；

3. 接口的默认方法，也可以被接口实现类进行**覆盖重写**。

   

### ③静态方法(static)

从Java8开始，接口里允许定义静态方法。

格式：

```java
public static 返回值类型 方法名称(参数列表){
    方法体;
}
```

使用

1. 不能通过接口实现类的对象来调用接口中的静态方法（一个实现类可以实现多个接口）；
2. 正确用法：通过接口名称直接调用其中的静态方法。



### ④私有方法(private)

从Java9开始，接口里允许定义私有方法：

1. 普通私有方法：解决多个默认方法之间重复代码问题；

格式：

```java
private 返回值类型 方法名称(参数列表){
    方法体
}
```



1. 静态私有方法：解决多个静态方法之间重复代码问题；

```java
private static 返回值类型 方法名称(参数列表){
    方法体
}
```



## 10.3 常量的定义与使用

接口当中也可以定义“成员变量”，但是必须使用 `public static final`三个关键字进行修饰。

从效果上看，这其实就是接口的【常量】。

格式：

```java
public static final 数据类型 常量名称 = 数据值;
```

注意：

1. 使用`final`关键字，说明不可改变。

2. 接口当中常量可以省略`public static final`三个关键字，不写也会触发。
3. 接口当中的常量必须进行赋值，不能不赋值。
4. 接口当中的常量，名字要用完全大写，多个单词用 "_" 连接。（推荐命名规则）



## 10.4 注意事项

1. 接口不能有静态代码块或者构造方法；

2. 一个类的直接父类是唯一的，但一个类可以同时实现多个接口，

   格式：

   ```java
   public class 类名 implements 接口1, 接口2, ...{
       
   }
   ```

3. 如果实现类实现的接口中有重复的抽象方法，只需要覆盖重写一次；

4. 如果实现类没有覆盖重写所有抽象方法，实现类必须是抽象类；

5. 如果实现类实现的接口中有重复的默认方法，那么实现类一定要对冲突的默认方法进行**覆盖重写**；

6. 一个类如果直接父类的方法，和接口中的默认方法产生了冲突，优先用父类的方法。



## 10.5 接口间的多继承

1. 类与类之间是但继承的，直接父类只有一个；
2. 类与接口直接是多实现的。一个类可以实现多个接口；
3. 接口与接口之间是**多继承**的。

注意事项：

1. 多个父接口之间的抽象方法可以重复；
2. 多个父接口之间的默认方法不可重复，需要重写，且带着default关键字。



# 第十一章 final关键字

final关键字代表最终、**不可改变**的。

final的4种常见用法：

1. 可以用来修饰一个类
2. 可以用来修饰一个方法
3. 可以用来修饰一个局部变量
4. 可以用来修饰一个成员变量



## 11.1 修饰类

 final关键词用来修饰一个类时：

- 格式：

   ```java
   public final class 类名称{}
   ```

- 含义：当前类不能有任何**子类**

- 注意：一个类如果是final，那么其中所有成员方法都无法覆盖重写，



## 11.2 修饰方法

+ 含义：final修饰方法时，该方法**不能被覆盖重写**。

+ 格式：

```java
public final 返回值类型 方法名称(参数列表){}
```

+ 注意：对于类和方法来说，final关键字和abstract关键字不能同时使用，因为矛盾。



## 11.3 修饰局部变量

+ 含义：final修饰局部变量时，该变量不能进行更改。

+ 格式：可以直接赋值，也可以先创建再赋值；

```java
int final num = xxx;
//或者
int final num;
num = xxx;
```

+ 注意事项：

  对于基本类型来说，不可变说的是变量当中的数据不可变；

  对于引用类型来说，不可变说的是**地址值**不可变。



## 11.4 修饰成员变量

- 含义：final修饰成员变量时，该变量不能进行更改。
- 注意：
  1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值；
  2. 对于使用final的成员变量，要么使用直接赋值，要么通过构造方法赋值；
  3. 必须保证**所有重载方法**都会对成员变量进行赋值；



# 第十二章 权限修饰符

Java中有四种权限修饰符：

|              | public | protected | (default) | private |
| ------------ | :----: | :-------: | :-------: | :-----: |
| 同一个类     |   ✔️    |     ✔️     |     ✔️     |    ✔️    |
| 同一个包     |   ✔️    |     ✔️     |     ✔️     |    ❌    |
| 不同包子类   |   ✔️    |     ✔️     |     ❌     |    ❌    |
| 不同包非子类 |   ✔️    |     ❌     |     ❌     |    ❌    |

注：子包不算同一个包



# 第十三章 内部类

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类（内部类）。

例如：身体和心脏的关系、汽车和发动机的关系。

内部类分为**成员内部类**和**局部内部类**（含匿名内部类）。



## 13.1 成员内部类

+ 成员内部类的定义格式：

```java
修饰符 class 外部类名称{
    修饰符 class 内部类名称{
        ...
    }
}
```

+ 注意：内用外，随意访问；外用内，需要内部类对象。

+ 使用：

  1. 间接方式：在外部类的方法中，使用内部类；main只是调用外部类的方法。

  2. 直接方式：公式：

     ```java
     类名称 对象名 = new 类名称; //正常方式
     外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
     ```

+ 同名变量访问：

  ```java
  // 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
  public class Outter{
  
      int num = 10; // 外部类的成员变量
      
      public  class inner{
          int num = 20; // 内部类的成员变量
          
          public void methodInner(){
              int num = 30; // 内部方法的局部变量
              System.out.println(num); // 10
              System.out.println(this.num); // 20
              System.out.println(Outer.this.num); // 30
          }
      }
  }
  ```

  

## 13.2 局部内部类（包含匿名内部类）

+ 定义：如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

+ “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 

+ 定义格式：

  ```java
  修饰符 class 外部类名称{
  	修饰符 返回值类型 外部类方法名称(参数列表){
  		class 局部内部类名称{
              ...
          }
      }
  }
  ```

+ 注意：

  局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是**有效final的**（从 Java 8+开始，可以不写final，但只能赋值一次）

  原因：

  1. new出来的对象在堆内存中；
  2. 局部变量时跟着方法走的，在栈内存当中；
  3. 方法运行结束之后立刻出栈，局部变量立刻消失；
  4. 但new出来的对象会在堆当中持续存在，直到垃圾回收消失。

+ 小结一下类的权限修饰符
  1. 外部类：public、default
  2. 成员内部类：public、protected、default、private
  3. 局部内部类：什么都不能写

### **匿名内部类**

如果接口的实现类（或者父类的子类）只需要使用唯一的一次，那么这种情况下可以省略掉该类的定义，改为使用**匿名内部类**。

+ 定义格式：

  ```java
  接口名称 对象名 = new 接口名称(){
      覆盖重写所有抽象方法；
  }
  ```

+ 注意事项

  1. 匿名内部类在**创建对象**的时候，只能使用唯一一次；

  2. 匿名对象在**调用方法**的时候只能调用一次；

  3. 匿名内部类是省略了实现类或子类，但匿名对象是省略了对象名称。

     匿名内部类和匿名对象不是一回事！

     



